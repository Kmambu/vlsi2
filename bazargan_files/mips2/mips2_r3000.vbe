
-- ### -------------------------------------------------------------- ###
-- # file	: mips2_r3000.vbe					#
-- # date	: Oct 18 2005						#
-- # version	: v1.1							#
-- #									#
-- # origin	: this description has been developed at LIP6		#
-- #		  University Paris 6 - Pierre et Marie Curie		#
-- #		  4 Place Jussieu 75252 Paris Cedex 05 - France		#
-- #									#
-- # descr.	: data flow description of a five stage pipelined Mips	#
-- #		  R3000 processor					#
-- #									#
-- # authors	: P. Bazargan Sabet					#
-- ### -------------------------------------------------------------- ###

entity MIPS2_R3000 is

  port (
       signal CK       : in    bit                          ;-- external clock
       signal RESET_N  : in    bit                          ;-- external reset
       signal IT_N     : in    bit_vector (  5 downto 0)    ;-- hw interrupts

       signal I_A      : out   bit_vector ( 31 downto 0)    ;-- inst address
       signal I_FTCH   : out   bit                          ;-- inst fetch
       signal I_ACK    : out   bit                          ;-- inst fetch ack
       signal I_BERR_N : in    bit                          ;-- inst bus error
       signal I_FRZ    : in    bit                          ;-- inst cache busy
       signal I        : in    bit_vector ( 63 downto 0)    ;-- instruction

       signal D_A      : out   bit_vector ( 31 downto 0)    ;-- data address
       signal D_RQ     : out   bit                          ;-- data request
       signal D_LOCK   : out   bit                          ;-- locked access
       signal D_ATYPE  : out   bit_vector (  1 downto 0)    ;-- access type
       signal D_ACK    : out   bit                          ;-- data fetch ack
       signal D_BERR_N : in    bit                          ;-- data bus error
       signal D_FRZ    : in    bit                          ;-- data cache busy
       signal D_IN     : in    bit_vector ( 31 downto 0)    ;-- data (input )
       signal D_OUT    : out   bit_vector ( 31 downto 0)    ;-- data (output)

       signal TEST     : in    bit                          ;-- test mode
       signal SCIN     : in    bit                          ;-- scan in
       signal SCOUT    : out   bit                          ;-- scan out

       signal VDD      : in    bit                          ;--
       signal VSS      : in    bit                          ;--
       signal VDDP     : in    bit                          ;--
       signal VSSP     : in    bit
       );

end MIPS2_R3000;

--

-- ### -------------------------------------------------------------- ###
-- #   Internal description - contains the following sections:		#
-- #									#
-- #      - internal signal and register declarations			#
-- #      - constant declarations					#
-- #      - instructions' table						#
-- #      - signals and registers expression				#
-- #									#
-- #   Note : Each signal or register is suffixed by three letters.	#
-- #									#
-- #          The first letter identifies the type of the signal:	#
-- #            - R : a register					#
-- #            - S : signal related to the normal execution		#
-- #            - X : signal related to the interrupt or exception	#
-- #                  mechanisms					#
-- #									#
-- #          The second letter identifies the pipe stage in which the	#
-- #          signal or the register is assigned:			#
-- #            - I : Instruction Fetch					#
-- #            - D : Instruction Decode				#
-- #            - E : Execute						#
-- #            - M : Memory Access					#
-- #            - W : Write Back					#
-- #            - X : Unknown - signal not related to the execution of	#
-- #                  an instruction					#
-- #									#
-- #          The third letter identifies the superscalar pipeline	#
-- #          level:							#
-- #            - 0 : first  level					#
-- #            - 1 : second level					#
-- #            - 2 : third  level (instruction buffer)			#
-- #            - 3 : fourth level (instruction buffer)			#
-- #            - A : any - not related to a superscalar level or	#
-- #                  related to all levels - global signal or register	#
-- ### -------------------------------------------------------------- ###

architecture BEHAVIOURAL of MIPS2_R3000 is

signal CK_SXA      : bit                              ;-- internal clock

signal KILL_SI0    : bit                              ;-- kill      the inst
signal KILL_SI1    : bit                              ;-- kill      the inst
signal KILL_SI2    : bit                              ;-- kill      the inst
signal KILL_SI3    : bit                              ;-- kill      the inst
signal STALL_SI0   : bit                              ;-- stall     the inst
signal STALL_SI1   : bit                              ;-- stall     the inst
signal STALL_SI2   : bit                              ;-- stall     the inst
signal STALL_SI3   : bit                              ;-- stall     the inst
signal COPY_SI0    : bit                              ;-- duplicate the inst
signal COPY_SI1    : bit                              ;-- duplicate the inst
signal COPY_SI2    : bit                              ;-- duplicate the inst
signal COPY_SI3    : bit                              ;-- duplicate the inst
signal EXEC_SI0    : bit                              ;-- execute   the inst
signal EXEC_SI1    : bit                              ;-- execute   the inst
signal EXEC_SI2    : bit                              ;-- execute   the inst
signal EXEC_SI3    : bit                              ;-- execute   the inst
signal BUBBLE_SI0  : bit                              ;-- introduce bubble
signal BUBBLE_SI1  : bit                              ;-- introduce bubble
signal BUBBLE_SI2  : bit                              ;-- introduce bubble
signal BUBBLE_SI3  : bit                              ;-- introduce bubble
signal HOLD_SI0    : bit                              ;-- hold  the inst
signal HOLD_SI1    : bit                              ;-- hold  the inst
signal HOLD_SI2    : bit                              ;-- hold  the inst
signal HOLD_SI3    : bit                              ;-- hold  the inst
signal SHIFT_SI0   : bit                              ;-- shift new inst
signal SHIFT_SI1   : bit                              ;-- shift new inst
signal SHIFT_SI2   : bit                              ;-- shift new inst
signal SHIFT_SI3   : bit                              ;-- shift new inst
signal KEEP_SI0    : bit                              ;-- keep  the data
signal KEEP_SI1    : bit                              ;-- keep  the data
signal KEEP_SI2    : bit                              ;-- keep  the data
signal KEEP_SI3    : bit                              ;-- keep  the data
signal LOAD_SI0    : bit                              ;-- load  new data
signal LOAD_SI1    : bit                              ;-- load  new data
signal LOAD_SI2    : bit                              ;-- load  new data
signal LOAD_SI3    : bit                              ;-- load  new data

signal KILL_SD0    : bit                              ;-- kill      the inst
signal KILL_SD1    : bit                              ;-- kill      the inst
signal STALL_SD0   : bit                              ;-- stall     the inst
signal STALL_SD1   : bit                              ;-- stall     the inst
signal COPY_SD0    : bit                              ;-- duplicate the inst
signal COPY_SD1    : bit                              ;-- duplicate the inst
signal EXEC_SD0    : bit                              ;-- execute   the inst
signal EXEC_SD1    : bit                              ;-- execute   the inst
signal BUBBLE_SD0  : bit                              ;-- introduce bubble
signal BUBBLE_SD1  : bit                              ;-- introduce bubble
signal HOLD_SD0    : bit                              ;-- hold  the inst
signal HOLD_SD1    : bit                              ;-- hold  the inst
signal SHIFT_SD0   : bit                              ;-- shift new inst
signal SHIFT_SD1   : bit                              ;-- shift new inst
signal KEEP_SD0    : bit                              ;-- keep  the data
signal KEEP_SD1    : bit                              ;-- keep  the data
signal LOAD_SD0    : bit                              ;-- load  new data
signal LOAD_SD1    : bit                              ;-- load  new data

signal KILL_SE0    : bit                              ;-- kill      the inst
signal KILL_SE1    : bit                              ;-- kill      the inst
signal STALL_SE0   : bit                              ;-- stall     the inst
signal STALL_SE1   : bit                              ;-- stall     the inst
signal COPY_SE0    : bit                              ;-- duplicate the inst
signal COPY_SE1    : bit                              ;-- duplicate the inst
signal EXEC_SE0    : bit                              ;-- execute   the inst
signal EXEC_SE1    : bit                              ;-- execute   the inst
signal BUBBLE_SE0  : bit                              ;-- introduce bubble
signal BUBBLE_SE1  : bit                              ;-- introduce bubble
signal HOLD_SE0    : bit                              ;-- hold  the inst
signal HOLD_SE1    : bit                              ;-- hold  the inst
signal SHIFT_SE0   : bit                              ;-- shift new inst
signal SHIFT_SE1   : bit                              ;-- shift new inst
signal KEEP_SE0    : bit                              ;-- keep  the data
signal KEEP_SE1    : bit                              ;-- keep  the data
signal LOAD_SE0    : bit                              ;-- load  new data
signal LOAD_SE1    : bit                              ;-- load  new data

signal KILL_SM0    : bit                              ;-- kill      the inst
signal KILL_SM1    : bit                              ;-- kill      the inst
signal STALL_SM0   : bit                              ;-- stall     the inst
signal STALL_SM1   : bit                              ;-- stall     the inst
signal COPY_SM0    : bit                              ;-- duplicate the inst
signal COPY_SM1    : bit                              ;-- duplicate the inst
signal EXEC_SM0    : bit                              ;-- execute   the inst
signal EXEC_SM1    : bit                              ;-- execute   the inst
signal BUBBLE_SM0  : bit                              ;-- introduce bubble
signal BUBBLE_SM1  : bit                              ;-- introduce bubble
signal HOLD_SM0    : bit                              ;-- hold  the inst
signal HOLD_SM1    : bit                              ;-- hold  the inst
signal SHIFT_SM0   : bit                              ;-- shift new inst
signal SHIFT_SM1   : bit                              ;-- shift new inst
signal KEEP_SM0    : bit                              ;-- keep  the data
signal KEEP_SM1    : bit                              ;-- keep  the data
signal LOAD_SM0    : bit                              ;-- load  new data
signal LOAD_SM1    : bit                              ;-- load  new data

signal KILL_SW0    : bit                              ;-- kill      the inst
signal KILL_SW1    : bit                              ;-- kill      the inst
signal STALL_SW0   : bit                              ;-- stall     the inst
signal STALL_SW1   : bit                              ;-- stall     the inst
signal COPY_SW0    : bit                              ;-- duplicate the inst
signal COPY_SW1    : bit                              ;-- duplicate the inst
signal EXEC_SW0    : bit                              ;-- execute   the inst
signal EXEC_SW1    : bit                              ;-- execute   the inst
signal BUBBLE_SW0  : bit                              ;-- introduce bubble
signal BUBBLE_SW1  : bit                              ;-- introduce bubble
signal HOLD_SW0    : bit                              ;-- hold  the inst
signal HOLD_SW1    : bit                              ;-- hold  the inst
signal SHIFT_SW0   : bit                              ;-- shift new inst
signal SHIFT_SW1   : bit                              ;-- shift new inst
signal KEEP_SW0    : bit                              ;-- keep  the data
signal KEEP_SW1    : bit                              ;-- keep  the data
signal LOAD_SW0    : bit                              ;-- load  new data
signal LOAD_SW1    : bit                              ;-- load  new data

signal FI_SI0      : bit_vector (31 downto 0)         ;-- fetched   inst
signal FI_SI1      : bit_vector (31 downto 0)         ;-- fetched   inst
signal I_SI0       : bit_vector (31 downto 0)         ;-- effective inst
signal I_SI1       : bit_vector (31 downto 0)         ;-- effective inst

signal I_RI0       : reg_vector (31 downto 0) register;-- inst buffer
signal I_RI1       : reg_vector (31 downto 0) register;-- inst buffer
signal I_RI2       : reg_vector (31 downto 0) register;-- inst buffer
signal I_RI3       : reg_vector (31 downto 0) register;-- inst buffer
signal I_RD0       : reg_vector (31 downto 0) register;-- inst register
signal I_RD1       : reg_vector (31 downto 0) register;-- inst register
signal I_RE0       : reg_vector (31 downto 0) register;-- inst register
signal I_RE1       : reg_vector (31 downto 0) register;-- inst register
signal I_RM0       : reg_vector (31 downto 0) register;-- inst register
signal I_RM1       : reg_vector (31 downto 0) register;-- inst register

signal VFI_SI0     : bit                              ;-- valid fetched   inst
signal VFI_SI1     : bit                              ;-- valid fetched   inst
signal VI_SI0      : bit                              ;-- valid effective inst
signal VI_SI1      : bit                              ;-- valid effective inst

signal VI_RI0      : reg_bit                  register;-- valid inst
signal VI_RI1      : reg_bit                  register;-- valid inst
signal VI_RI2      : reg_bit                  register;-- valid inst
signal VI_RI3      : reg_bit                  register;-- valid inst

signal FIPC_SI0    : bit_vector (31 downto 0)         ;-- fecthed   inst addr
signal FIPC_SI1    : bit_vector (31 downto 0)         ;-- fecthed   inst addr
signal PC_SI0      : bit_vector (31 downto 0)         ;-- effective inst addr
signal PC_SI1      : bit_vector (31 downto 0)         ;-- effective inst addr

signal PC_RI0      : reg_vector (31 downto 0) register;-- cur inst address
signal PC_RI1      : reg_vector (31 downto 0) register;-- cur inst address
signal PC_RI2      : reg_vector (31 downto 0) register;-- cur inst address
signal PC_RI3      : reg_vector (31 downto 0) register;-- cur inst address
signal PC_RD0      : reg_vector (31 downto 0) register;-- cur inst address
signal PC_RD1      : reg_vector (31 downto 0) register;-- cur inst address
signal PC_RE0      : reg_vector (31 downto 0) register;-- cur inst address
signal PC_RE1      : reg_vector (31 downto 0) register;-- cur inst address

signal COP0_SD0    : bit_vector ( 7 downto 0)         ;-- cop0 extension
signal COP0_SD1    : bit_vector ( 7 downto 0)         ;-- cop0 extension

signal OPCOD_SD0   : bit_vector ( 7 downto 0)         ;-- operation code
signal OPCOD_SD1   : bit_vector ( 7 downto 0)         ;-- operation code

signal OPCOD_RD0   : reg_vector ( 7 downto 0) register;-- operation code
signal OPCOD_RD1   : reg_vector ( 7 downto 0) register;-- operation code
signal OPCOD_RE0   : reg_vector ( 7 downto 0) register;-- operation code
signal OPCOD_RE1   : reg_vector ( 7 downto 0) register;-- operation code
signal OPCOD_RM0   : reg_vector ( 7 downto 0) register;-- operation code
signal OPCOD_RM1   : reg_vector ( 7 downto 0) register;-- operation code

signal I_TYPE_SD0  : bit_vector (24 downto 0)         ;-- instruction type
signal I_TYPE_SD1  : bit_vector (24 downto 0)         ;-- instruction type
signal I_TYPE_RD0  : reg_vector (24 downto 0) register;-- instruction type
signal I_TYPE_RD1  : reg_vector (24 downto 0) register;-- instruction type

signal I_TYPE_RE0  : reg_vector (24 downto 0) register;-- instruction type
signal I_TYPE_RE1  : reg_vector (24 downto 0) register;-- instruction type

signal I_TYPE_RM0  : reg_vector (24 downto 0) register;-- instruction type
signal I_TYPE_RM1  : reg_vector (24 downto 0) register;-- instruction type

signal I_RFMT_SD0  : bit                              ;-- r format
signal I_RFMT_SD1  : bit                              ;-- r format
signal I_IFMT_SD0  : bit                              ;-- i format
signal I_IFMT_SD1  : bit                              ;-- i format
signal I_JFMT_SD0  : bit                              ;-- j format
signal I_JFMT_SD1  : bit                              ;-- j format
signal I_ILLG_SD0  : bit                              ;-- illegal instruction
signal I_ILLG_SD1  : bit                              ;-- illegal instruction
signal I_READS_SD0 : bit                              ;-- inst uses s oper
signal I_READS_SD1 : bit                              ;-- inst uses s oper
signal I_READT_SD0 : bit                              ;-- inst uses t oper
signal I_READT_SD1 : bit                              ;-- inst uses t oper
signal I_DUSE_SD0  : bit                              ;-- dec uses operands
signal I_DUSE_SD1  : bit                              ;-- dec uses operands
signal I_OSGND_SD0 : bit                              ;-- signed operands
signal I_OSGND_SD1 : bit                              ;-- signed operands
signal I_BRNCH_SD0 : bit                              ;-- branch instruction
signal I_BRNCH_SD1 : bit                              ;-- branch instruction
signal I_WRT31_SD0 : bit                              ;-- write into r31
signal I_WRT31_SD1 : bit                              ;-- write into r31
signal I_WRITE_SD0 : bit                              ;-- write into reg
signal I_WRITE_SD1 : bit                              ;-- write into reg

signal I_IFMT_SE0  : bit                              ;-- i format
signal I_IFMT_SE1  : bit                              ;-- i format
signal I_READS_SE0 : bit                              ;-- inst uses s oper
signal I_READS_SE1 : bit                              ;-- inst uses s oper
signal I_READT_SE0 : bit                              ;-- inst uses t oper
signal I_READT_SE1 : bit                              ;-- inst uses t oper
signal I_EUSE_SE0  : bit                              ;-- exe uses operands
signal I_EUSE_SE1  : bit                              ;-- exe uses operands
signal I_EPDC_SE0  : bit                              ;-- exe produces res
signal I_EPDC_SE1  : bit                              ;-- exe produces res
signal I_MPDC_SE0  : bit                              ;-- mem produces res
signal I_MPDC_SE1  : bit                              ;-- mem produces res
signal I_RSGND_SE0 : bit                              ;-- signed result
signal I_RSGND_SE1 : bit                              ;-- signed result
signal I_OPER_SE0  : bit_vector ( 2 downto 0)         ;-- alu operation
signal I_OPER_SE1  : bit_vector ( 2 downto 0)         ;-- alu operation
signal I_LOGIC_SE0 : bit_vector ( 1 downto 0)         ;-- logic operation
signal I_LOGIC_SE1 : bit_vector ( 1 downto 0)         ;-- logic operation
signal I_SUB_SE0   : bit                              ;-- subtract
signal I_SUB_SE1   : bit                              ;-- subtract
signal I_RIGHT_SE0 : bit                              ;-- shift right
signal I_RIGHT_SE1 : bit                              ;-- shift right
signal I_OVRF_SE0  : bit                              ;-- detect overflow
signal I_OVRF_SE1  : bit                              ;-- detect overflow
signal I_BRNCH_SE0 : bit                              ;-- branch instruction
signal I_BRNCH_SE1 : bit                              ;-- branch instruction
signal I_WRITE_SE0 : bit                              ;-- write into reg
signal I_WRITE_SE1 : bit                              ;-- write into reg

signal I_MPDC_SM0  : bit                              ;-- mem produces res
signal I_MPDC_SM1  : bit                              ;-- mem produces res
signal I_LOAD_SM0  : bit                              ;-- read  from memory
signal I_LOAD_SM1  : bit                              ;-- read  from memory
signal I_STOR_SM0  : bit                              ;-- write into memory
signal I_STOR_SM1  : bit                              ;-- write into memory
signal I_BYTE_SM0  : bit                              ;-- access type (byte)
signal I_BYTE_SM1  : bit                              ;-- access type (byte)
signal I_HALF_SM0  : bit                              ;-- access type (half)
signal I_HALF_SM1  : bit                              ;-- access type (half)
signal I_WORD_SM0  : bit                              ;-- access type (word)
signal I_WORD_SM1  : bit                              ;-- access type (word)
signal I_WRITE_SM0 : bit                              ;-- write into reg
signal I_WRITE_SM1 : bit                              ;-- write into reg
signal I_BRNCH_SM0 : bit                              ;-- branch instruction
signal I_BRNCH_SM1 : bit                              ;-- branch instruction

signal I_WRITE_SW0 : bit                              ;-- write into reg
signal I_WRITE_SW1 : bit                              ;-- write into reg

signal ISTAT_RE0   : reg_bit                  register;-- instruction state
signal ISTAT_RE1   : reg_bit                  register;-- instruction state

signal RS_SD0      : bit_vector ( 4 downto 0)         ;-- source reg nbr
signal RS_SD1      : bit_vector ( 4 downto 0)         ;-- source reg nbr
signal RT_SD0      : bit_vector ( 4 downto 0)         ;-- source reg nbr
signal RT_SD1      : bit_vector ( 4 downto 0)         ;-- source reg nbr
signal RS_RD0      : reg_vector ( 4 downto 0) register;-- source reg nbr
signal RS_RD1      : reg_vector ( 4 downto 0) register;-- source reg nbr
signal RT_RD0      : reg_vector ( 4 downto 0) register;-- source reg nbr
signal RT_RD1      : reg_vector ( 4 downto 0) register;-- source reg nbr

signal RD_SD0      : bit_vector ( 4 downto 0)         ;-- destination reg nbr
signal RD_SD1      : bit_vector ( 4 downto 0)         ;-- destination reg nbr
signal RD_RD0      : reg_vector ( 4 downto 0) register;-- destination reg nbr
signal RD_RD1      : reg_vector ( 4 downto 0) register;-- destination reg nbr
signal RD_RE0      : reg_vector ( 4 downto 0) register;-- destination reg nbr
signal RD_RE1      : reg_vector ( 4 downto 0) register;-- destination reg nbr
signal RD_SM0      : bit_vector ( 4 downto 0)         ;-- destination reg nbr
signal RD_SM1      : bit_vector ( 4 downto 0)         ;-- destination reg nbr
signal RD_RM0      : reg_vector ( 4 downto 0) register;-- destination reg nbr
signal RD_RM1      : reg_vector ( 4 downto 0) register;-- destination reg nbr

signal COP0D_SD0   : bit_vector ( 4 downto 0)         ;-- cop 0 dest reg nbr
signal COP0D_SD1   : bit_vector ( 4 downto 0)         ;-- cop 0 dest reg nbr
signal COP0D_RD0   : reg_vector ( 4 downto 0) register;-- cop 0 dest reg nbr
signal COP0D_RD1   : reg_vector ( 4 downto 0) register;-- cop 0 dest reg nbr
signal COP0D_RE0   : reg_vector ( 4 downto 0) register;-- cop 0 dest reg nbr
signal COP0D_RE1   : reg_vector ( 4 downto 0) register;-- cop 0 dest reg nbr

signal S_SD0       : bit_vector (31 downto 0)         ;-- s from reg bank
signal S_SD1       : bit_vector (31 downto 0)         ;-- s from reg bank
signal SOPER_SD0   : bit_vector (31 downto 0)         ;-- effective s oper
signal SOPER_SD1   : bit_vector (31 downto 0)         ;-- effective s oper
signal SOPER_RD0   : reg_vector (31 downto 0) register;-- effective s oper
signal SOPER_RD1   : reg_vector (31 downto 0) register;-- effective s oper

signal T_SD0       : bit_vector (31 downto 0)         ;-- t from reg bank
signal T_SD1       : bit_vector (31 downto 0)         ;-- t from reg bank
signal TOPER_SD0   : bit_vector (31 downto 0)         ;-- effective t oper
signal TOPER_SD1   : bit_vector (31 downto 0)         ;-- effective t oper
signal TOPER_RD0   : reg_vector (31 downto 0) register;-- effective t oper
signal TOPER_RD1   : reg_vector (31 downto 0) register;-- effective t oper

signal IOPER_SD0   : bit_vector (31 downto 0)         ;-- eff immediate oper
signal IOPER_SD1   : bit_vector (31 downto 0)         ;-- eff immediate oper
signal IOPER_RD0   : reg_vector (31 downto 0) register;-- eff immediate oper
signal IOPER_RD1   : reg_vector (31 downto 0) register;-- eff immediate oper

signal COP0OP_SD0  : bit_vector (31 downto 0)         ;-- cop 0 source opr
signal COP0OP_SD1  : bit_vector (31 downto 0)         ;-- cop 0 source opr

signal SOPER_SE0   : bit_vector (31 downto 0)         ;-- s operand
signal SOPER_SE1   : bit_vector (31 downto 0)         ;-- s operand
signal XARITH_SE0  : bit_vector (31 downto 0)         ;-- x oper for arithm
signal XARITH_SE1  : bit_vector (31 downto 0)         ;-- x oper for arithm

signal TOPER_SE0   : bit_vector (31 downto 0)         ;-- t operand
signal TOPER_SE1   : bit_vector (31 downto 0)         ;-- t operand
signal YARITH_SE0  : bit_vector (31 downto 0)         ;-- y oper for arithm
signal YARITH_SE1  : bit_vector (31 downto 0)         ;-- y oper for arithm

signal IREAD_SIA   : bit                              ;-- new inst fetched
signal IREAD_RIA   : reg_bit                  register;-- new inst fetched

signal S_CMP_T_SD0 : bit_vector (31 downto 0)         ;-- compare s & t
signal S_CMP_T_SD1 : bit_vector (31 downto 0)         ;-- compare s & t
signal S_EQ_T_SD0  : bit                              ;-- s =  t
signal S_EQ_T_SD1  : bit                              ;-- s =  t
signal S_LT_Z_SD0  : bit                              ;-- s <  0
signal S_LT_Z_SD1  : bit                              ;-- s <  0
signal S_LE_Z_SD0  : bit                              ;-- s <= 0
signal S_LE_Z_SD1  : bit                              ;-- s <= 0

signal IMDSEX_SD0  : bit_vector (15 downto 0)         ;-- offset extension
signal IMDSEX_SD1  : bit_vector (15 downto 0)         ;-- offset extension
signal OFFSET_SD0  : bit_vector (31 downto 0)         ;-- address offset
signal OFFSET_SD1  : bit_vector (31 downto 0)         ;-- address offset

signal SEQADR_SD0  : bit_vector (31 downto 0)         ;-- sequential inst adr
signal SEQCRY_SD0  : bit_vector (32 downto 0)         ;-- carry
signal SEQADR_SD1  : bit_vector (31 downto 0)         ;-- sequential inst adr
signal SEQCRY_SD1  : bit_vector (32 downto 0)         ;-- carry
signal SEQADR_SDA  : bit_vector (31 downto 0)         ;-- sequential inst adr

signal SUCCBRA_SD0 : bit                              ;-- successful branch
signal SUCCBRA_SD1 : bit                              ;-- successful branch

signal MISPRED_SD0 : bit                              ;-- mispredicted branch
signal MISPRED_SD1 : bit                              ;-- mispredicted branch

signal LNKPC_SD0   : bit_vector (31 downto 0)         ;-- link adr
signal LNKPC_SD1   : bit_vector (31 downto 0)         ;-- link adr

signal DSPC_SD0    : bit_vector (31 downto 0)         ;-- branch dly slot adr
signal DSPC_SD1    : bit_vector (31 downto 0)         ;-- branch dly slot adr

signal JMPADR_SD0  : bit_vector (31 downto 0)         ;-- jump address
signal JMPADR_SD1  : bit_vector (31 downto 0)         ;-- jump address
signal BRAADR_SD0  : bit_vector (31 downto 0)         ;-- branch address
signal BRAADR_SD1  : bit_vector (31 downto 0)         ;-- branch address
signal BRACRY_SD0  : bit_vector (32 downto 0)         ;-- carry (+ offset)
signal BRACRY_SD1  : bit_vector (32 downto 0)         ;-- carry (+ offset)

signal NEXTPC_XXA  : bit_vector (31 downto 0)         ;-- next instr adr (hw)
signal NEXTPC_SD0  : bit_vector (31 downto 0)         ;-- next instr address
signal NEXTPC_SD1  : bit_vector (31 downto 0)         ;-- next instr address

signal NEXTPC_RDA  : reg_vector (31 downto 0) register;-- next instr address
signal NEXTPC_REA  : reg_vector (31 downto 0) register;-- next instr address

signal MALGNPC_SIA : bit                              ;-- inst adr not * 8 

signal XOPER_SE0   : bit_vector (31 downto 0)         ;-- effective x operand
signal XOPER_SE1   : bit_vector (31 downto 0)         ;-- effective x operand
signal YOPER_SE0   : bit_vector (31 downto 0)         ;-- effective y operand
signal YOPER_SE1   : bit_vector (31 downto 0)         ;-- effective y operand

signal CARITH_SE0  : bit_vector (32 downto 0)         ;-- carry in arithm
signal CARITH_SE1  : bit_vector (32 downto 0)         ;-- carry in arithm
signal RARITH_SE0  : bit_vector (31 downto 0)         ;-- result of arithm
signal RARITH_SE1  : bit_vector (31 downto 0)         ;-- result of arithm

signal SHIFTIN_SE0 : bit_vector (31 downto 0)         ;-- shift in
signal SHIFTIN_SE1 : bit_vector (31 downto 0)         ;-- shift in
signal SHRIGHT_SE0 : bit_vector (31 downto 0)         ;-- right shift result
signal SHRIGHT_SE1 : bit_vector (31 downto 0)         ;-- right shift result
signal SHLEFT_SE0  : bit_vector (31 downto 0)         ;-- left  shift result
signal SHLEFT_SE1  : bit_vector (31 downto 0)         ;-- left  shift result
signal RSHIFT_SE0  : bit_vector (31 downto 0)         ;-- shifter's result
signal RSHIFT_SE1  : bit_vector (31 downto 0)         ;-- shifter's result

signal RLOGIC_SE0  : bit_vector (31 downto 0)         ;-- logic oper result
signal RLOGIC_SE1  : bit_vector (31 downto 0)         ;-- logic oper result

signal S_LT_T_SE0  : bit                              ;-- s <  t
signal S_LT_T_SE1  : bit                              ;-- s <  t
signal S_LTU_T_SE0 : bit                              ;-- s <  t unsigned
signal S_LTU_T_SE1 : bit                              ;-- s <  t unsigned
signal SETBIT_SE0  : bit                              ;-- test out of set ins
signal SETBIT_SE1  : bit                              ;-- test out of set ins
signal RTEST_SE0   : bit_vector (31 downto 0)         ;-- test oper result
signal RTEST_SE1   : bit_vector (31 downto 0)         ;-- test oper result

signal RES_SE0     : bit_vector (31 downto 0)         ;-- result out of alu
signal RES_SE1     : bit_vector (31 downto 0)         ;-- result out of alu
signal RES_RE0     : reg_vector (31 downto 0) register;-- result out of alu
signal RES_RE1     : reg_vector (31 downto 0) register;-- result out of alu

signal WDATA_RE0   : reg_vector (31 downto 0) register;-- data bus output reg
signal WDATA_RE1   : reg_vector (31 downto 0) register;-- data bus output reg

signal WREDOPC_SE0 : bit                              ;-- redopc write enable
signal WREDOPC_SE1 : bit                              ;-- redopc write enable
signal WREDOPC_SM0 : bit                              ;-- redopc write enable
signal WREDOPC_SM1 : bit                              ;-- redopc write enable

signal REDOPC_REA  : reg_vector (31 downto 0) register;-- branch inst address
signal REDOPC_RMA  : reg_vector (31 downto 0) register;-- branch inst address

signal DACCESS_SM0 : bit                              ;-- data memory access
signal DACCESS_SM1 : bit                              ;-- data memory access

signal DATYPE_SM0  : bit_vector ( 1 downto 0)         ;-- data access type
signal DATYPE_SM1  : bit_vector ( 1 downto 0)         ;-- data access type

signal DREAD_SM0   : bit                              ;-- data read
signal DREAD_SM1   : bit                              ;-- data read
signal DREAD_RM0   : reg_bit                  register;-- data read
signal DREAD_RM1   : reg_bit                  register;-- data read

signal WRITE_SM0   : bit                              ;-- write into storage
signal WRITE_SM1   : bit                              ;-- write into storage

signal DLOCK_SM0   : bit                              ;-- lock data access
signal DLOCK_SM1   : bit                              ;-- lock data access

signal BYTSEL_SM0  : bit_vector ( 3 downto 0)         ;-- byte select for rw
signal BYTSEL_SM1  : bit_vector ( 3 downto 0)         ;-- byte select for rw

signal BSEXT_SM0   : bit_vector (23 downto 0)         ;-- data sign ext byte
signal BSEXT_SM1   : bit_vector (23 downto 0)         ;-- data sign ext byte

signal HSEXT_SM0   : bit_vector (15 downto 0)         ;-- data sign ext half
signal HSEXT_SM1   : bit_vector (15 downto 0)         ;-- data sign ext half

signal REDDAT_SM0  : bit_vector (31 downto 0)         ;-- aligned data
signal REDDAT_SM1  : bit_vector (31 downto 0)         ;-- aligned data

signal DATA_SM0    : bit_vector (31 downto 0)         ;-- data bus / res
signal DATA_SM1    : bit_vector (31 downto 0)         ;-- data bus / res
signal DATA_RM0    : reg_vector (31 downto 0) register;-- data bus / res
signal DATA_RM1    : reg_vector (31 downto 0) register;-- data bus / res

signal R1_RWA      : reg_vector (31 downto 0) register;-- integer reg  1
signal R2_RWA      : reg_vector (31 downto 0) register;-- integer reg  2
signal R3_RWA      : reg_vector (31 downto 0) register;-- integer reg  3
signal R4_RWA      : reg_vector (31 downto 0) register;-- integer reg  4
signal R5_RWA      : reg_vector (31 downto 0) register;-- integer reg  5
signal R6_RWA      : reg_vector (31 downto 0) register;-- integer reg  6
signal R7_RWA      : reg_vector (31 downto 0) register;-- integer reg  7
signal R8_RWA      : reg_vector (31 downto 0) register;-- integer reg  8
signal R9_RWA      : reg_vector (31 downto 0) register;-- integer reg  9
signal R10_RWA     : reg_vector (31 downto 0) register;-- integer reg 10
signal R11_RWA     : reg_vector (31 downto 0) register;-- integer reg 11
signal R12_RWA     : reg_vector (31 downto 0) register;-- integer reg 12
signal R13_RWA     : reg_vector (31 downto 0) register;-- integer reg 13
signal R14_RWA     : reg_vector (31 downto 0) register;-- integer reg 14
signal R15_RWA     : reg_vector (31 downto 0) register;-- integer reg 15
signal R16_RWA     : reg_vector (31 downto 0) register;-- integer reg 16
signal R17_RWA     : reg_vector (31 downto 0) register;-- integer reg 17
signal R18_RWA     : reg_vector (31 downto 0) register;-- integer reg 18
signal R19_RWA     : reg_vector (31 downto 0) register;-- integer reg 19
signal R20_RWA     : reg_vector (31 downto 0) register;-- integer reg 20
signal R21_RWA     : reg_vector (31 downto 0) register;-- integer reg 21
signal R22_RWA     : reg_vector (31 downto 0) register;-- integer reg 22
signal R23_RWA     : reg_vector (31 downto 0) register;-- integer reg 23
signal R24_RWA     : reg_vector (31 downto 0) register;-- integer reg 24
signal R25_RWA     : reg_vector (31 downto 0) register;-- integer reg 25
signal R26_RWA     : reg_vector (31 downto 0) register;-- integer reg 26
signal R27_RWA     : reg_vector (31 downto 0) register;-- integer reg 27
signal R28_RWA     : reg_vector (31 downto 0) register;-- integer reg 28
signal R29_RWA     : reg_vector (31 downto 0) register;-- integer reg 29
signal R30_RWA     : reg_vector (31 downto 0) register;-- integer reg 30
signal R31_RWA     : reg_vector (31 downto 0) register;-- integer reg 31

signal WLO_SW0     : bit                              ;-- lo  reg's write en
signal WLO_SW1     : bit                              ;-- lo  reg's write en
signal WHI_SW0     : bit                              ;-- hi  reg's write en
signal WHI_SW1     : bit                              ;-- hi  reg's write en
signal LO_RWA      : reg_vector (31 downto 0) register;-- lo  register
signal HI_RWA      : reg_vector (31 downto 0) register;-- hi  register

signal COPERR_XMA  : bit_vector ( 1 downto 0)         ;-- coprocessor's #

signal EXCCODE_XM0 : bit_vector ( 3 downto 0)         ;-- exception code
signal EXCCODE_XM1 : bit_vector ( 3 downto 0)         ;-- exception code

signal WCAUSE_XM0  : bit                              ;-- cause wen (exp)
signal WCAUSE_XM1  : bit                              ;-- cause wen (exp)
signal WCAUSE_SM0  : bit                              ;-- cause wen (sw)
signal WCAUSE_SM1  : bit                              ;-- cause wen (sw)

signal CAUSE_XM0   : bit_vector (31 downto 0)         ;-- cause (exp)
signal CAUSE_XM1   : bit_vector (31 downto 0)         ;-- cause (exp)
signal CAUSE_XXA   : bit_vector (31 downto 0)         ;-- cause (int)
signal CAUSE_SM0   : bit_vector (31 downto 0)         ;-- cause (sw)
signal CAUSE_SM1   : bit_vector (31 downto 0)         ;-- cause (sw)
signal CAUSE_SXA   : bit_vector (31 downto 0)         ;-- cause (hw)

signal CAUSE_RXA   : reg_vector (31 downto 0) register;-- cause register

signal RSTORSR_SMA : bit_vector (31 downto 0)         ;-- next ins sts (rfe)

signal NEXTSR_SM0  : bit_vector (31 downto 0)         ;-- next ins sts (sw)
signal NEXTSR_SM1  : bit_vector (31 downto 0)         ;-- next ins sts (sw)
signal NEXTSR_XXA  : bit_vector (31 downto 0)         ;-- next ins sts (hw it)
signal NEXTSR_RXA  : reg_vector (31 downto 0) register;-- next ins sts reg

signal MODE_XXA    : bit                              ;-- processor's mode
signal MODE_SD0    : bit                              ;-- processor's mode
signal MODE_SD1    : bit                              ;-- processor's mode
signal MODE_RD0    : reg_bit                  register;-- processor's mode
signal MODE_RD1    : reg_bit                  register;-- processor's mode
signal MODE_RE0    : reg_bit                  register;-- processor's mode
signal MODE_RE1    : reg_bit                  register;-- processor's mode

signal WSR_SM0     : bit                              ;-- nextsr's write en
signal WSR_SM1     : bit                              ;-- nextsr's write en
signal WSR_XXA     : bit                              ;-- nextsr's write en

signal SAVSAME_SIA : bit                              ;
signal PRECED_SIA  : bit                              ;-- level 0 preceds 1
signal PRECED_RIA  : reg_bit                  register;-- level 0 preceds 1
signal PRECED_RDA  : reg_bit                  register;-- level 0 preceds 1
signal PRECED_REA  : reg_bit                  register;-- level 0 preceds 1
signal PRECED_RMA  : reg_bit                  register;-- level 0 preceds 1

signal CP_SDD0_SD1 : bit_vector ( 4 downto 0)         ;-- compare s d
signal CP_SDD1_SD0 : bit_vector ( 4 downto 0)         ;-- compare s d
signal CP_SDE0_SD0 : bit_vector ( 4 downto 0)         ;-- compare s d(p-1)
signal CP_SDE0_SD1 : bit_vector ( 4 downto 0)         ;-- compare s d(p-1)
signal CP_SDE1_SD0 : bit_vector ( 4 downto 0)         ;-- compare s d(p-1)
signal CP_SDE1_SD1 : bit_vector ( 4 downto 0)         ;-- compare s d(p-1)
signal CP_SDM0_SD0 : bit_vector ( 4 downto 0)         ;-- compare s d(p-2)
signal CP_SDM0_SD1 : bit_vector ( 4 downto 0)         ;-- compare s d(p-2)
signal CP_SDM1_SD0 : bit_vector ( 4 downto 0)         ;-- compare s d(p-2)
signal CP_SDM1_SD1 : bit_vector ( 4 downto 0)         ;-- compare s d(p-2)
signal CP_SDW0_SD0 : bit_vector ( 4 downto 0)         ;-- compare s d(p-3)
signal CP_SDW0_SD1 : bit_vector ( 4 downto 0)         ;-- compare s d(p-3)
signal CP_SDW1_SD0 : bit_vector ( 4 downto 0)         ;-- compare s d(p-3)
signal CP_SDW1_SD1 : bit_vector ( 4 downto 0)         ;-- compare s d(p-3)

signal CP_TDD0_SD1 : bit_vector ( 4 downto 0)         ;-- compare t d
signal CP_TDD1_SD0 : bit_vector ( 4 downto 0)         ;-- compare t d
signal CP_TDE0_SD0 : bit_vector ( 4 downto 0)         ;-- compare t d(p-1)
signal CP_TDE0_SD1 : bit_vector ( 4 downto 0)         ;-- compare t d(p-1)
signal CP_TDE1_SD0 : bit_vector ( 4 downto 0)         ;-- compare t d(p-1)
signal CP_TDE1_SD1 : bit_vector ( 4 downto 0)         ;-- compare t d(p-1)
signal CP_TDM0_SD0 : bit_vector ( 4 downto 0)         ;-- compare t d(p-2)
signal CP_TDM0_SD1 : bit_vector ( 4 downto 0)         ;-- compare t d(p-2)
signal CP_TDM1_SD0 : bit_vector ( 4 downto 0)         ;-- compare t d(p-2)
signal CP_TDM1_SD1 : bit_vector ( 4 downto 0)         ;-- compare t d(p-2)
signal CP_TDW0_SD0 : bit_vector ( 4 downto 0)         ;-- compare t d(p-3)
signal CP_TDW0_SD1 : bit_vector ( 4 downto 0)         ;-- compare t d(p-3)
signal CP_TDW1_SD0 : bit_vector ( 4 downto 0)         ;-- compare t d(p-3)
signal CP_TDW1_SD1 : bit_vector ( 4 downto 0)         ;-- compare t d(p-3)

signal CP_SDE0_SE1 : bit_vector ( 4 downto 0)         ;-- compare s d
signal CP_SDE1_SE0 : bit_vector ( 4 downto 0)         ;-- compare s d
signal CP_SDM0_SE0 : bit_vector ( 4 downto 0)         ;-- compare s d(p-1)
signal CP_SDM0_SE1 : bit_vector ( 4 downto 0)         ;-- compare s d(p-1)
signal CP_SDM1_SE0 : bit_vector ( 4 downto 0)         ;-- compare s d(p-1)
signal CP_SDM1_SE1 : bit_vector ( 4 downto 0)         ;-- compare s d(p-1)
signal CP_SDW0_SE0 : bit_vector ( 4 downto 0)         ;-- compare s d(p-2)
signal CP_SDW0_SE1 : bit_vector ( 4 downto 0)         ;-- compare s d(p-2)
signal CP_SDW1_SE0 : bit_vector ( 4 downto 0)         ;-- compare s d(p-2)
signal CP_SDW1_SE1 : bit_vector ( 4 downto 0)         ;-- compare s d(p-2)

signal CP_TDE0_SE1 : bit_vector ( 4 downto 0)         ;-- compare s d
signal CP_TDE1_SE0 : bit_vector ( 4 downto 0)         ;-- compare s d
signal CP_TDM0_SE0 : bit_vector ( 4 downto 0)         ;-- compare t d(p-1)
signal CP_TDM0_SE1 : bit_vector ( 4 downto 0)         ;-- compare t d(p-1)
signal CP_TDM1_SE0 : bit_vector ( 4 downto 0)         ;-- compare t d(p-1)
signal CP_TDM1_SE1 : bit_vector ( 4 downto 0)         ;-- compare t d(p-1)
signal CP_TDW0_SE0 : bit_vector ( 4 downto 0)         ;-- compare t d(p-2)
signal CP_TDW0_SE1 : bit_vector ( 4 downto 0)         ;-- compare t d(p-2)
signal CP_TDW1_SE0 : bit_vector ( 4 downto 0)         ;-- compare t d(p-2)
signal CP_TDW1_SE1 : bit_vector ( 4 downto 0)         ;-- compare t d(p-2)

signal CP_DDW0_SW1 : bit_vector ( 4 downto 0)         ;-- compare d d(p  )
signal CP_DDW1_SW0 : bit_vector ( 4 downto 0)         ;-- compare d d(p  )

signal SREADR0_SD0 : bit                              ;-- reading r0 on s
signal SREADR0_SD1 : bit                              ;-- reading r0 on s
signal SREADR0_SE0 : bit                              ;-- reading r0 on s
signal SREADR0_SE1 : bit                              ;-- reading r0 on s
signal TREADR0_SD0 : bit                              ;-- reading r0 on t
signal TREADR0_SD1 : bit                              ;-- reading r0 on t
signal TREADR0_SE0 : bit                              ;-- reading r0 on t
signal TREADR0_SE1 : bit                              ;-- reading r0 on t
signal WRITER0_SW0 : bit                              ;-- writing r0
signal WRITER0_SW1 : bit                              ;-- writing r0

signal HZ_SDD0_SD1 : bit                              ;-- effec s = d(p  )
signal HZ_SDD1_SD0 : bit                              ;-- effec s = d(p  )
signal HZ_SDE0_SD0 : bit                              ;-- effec s = d(p-1)
signal HZ_SDE0_SD1 : bit                              ;-- effec s = d(p-1)
signal HZ_SDE1_SD0 : bit                              ;-- effec s = d(p-1)
signal HZ_SDE1_SD1 : bit                              ;-- effec s = d(p-1)
signal HZ_SDM0_SD0 : bit                              ;-- effec s = d(p-2)
signal HZ_SDM0_SD1 : bit                              ;-- effec s = d(p-2)
signal HZ_SDM1_SD0 : bit                              ;-- effec s = d(p-2)
signal HZ_SDM1_SD1 : bit                              ;-- effec s = d(p-2)
signal HZ_SDW0_SD0 : bit                              ;-- effec s = d(p-3)
signal HZ_SDW0_SD1 : bit                              ;-- effec s = d(p-3)
signal HZ_SDW1_SD0 : bit                              ;-- effec s = d(p-3)
signal HZ_SDW1_SD1 : bit                              ;-- effec s = d(p-3)

signal HZ_TDD0_SD1 : bit                              ;-- effec t = d(p  )
signal HZ_TDD1_SD0 : bit                              ;-- effec t = d(p  )
signal HZ_TDE0_SD0 : bit                              ;-- effec t = d(p-1)
signal HZ_TDE0_SD1 : bit                              ;-- effec t = d(p-1)
signal HZ_TDE1_SD0 : bit                              ;-- effec t = d(p-1)
signal HZ_TDE1_SD1 : bit                              ;-- effec t = d(p-1)
signal HZ_TDM0_SD0 : bit                              ;-- effec t = d(p-2)
signal HZ_TDM0_SD1 : bit                              ;-- effec t = d(p-2)
signal HZ_TDM1_SD0 : bit                              ;-- effec t = d(p-2)
signal HZ_TDM1_SD1 : bit                              ;-- effec t = d(p-2)
signal HZ_TDW0_SD0 : bit                              ;-- effec t = d(p-3)
signal HZ_TDW0_SD1 : bit                              ;-- effec t = d(p-3)
signal HZ_TDW1_SD0 : bit                              ;-- effec t = d(p-3)
signal HZ_TDW1_SD1 : bit                              ;-- effec t = d(p-3)

signal HZ_SDE0_SE1 : bit                              ;-- effec s = d(p  )
signal HZ_SDE1_SE0 : bit                              ;-- effec s = d(p  )
signal HZ_SDM0_SE0 : bit                              ;-- effec s = d(p-1)
signal HZ_SDM0_SE1 : bit                              ;-- effec s = d(p-1)
signal HZ_SDM1_SE0 : bit                              ;-- effec s = d(p-1)
signal HZ_SDM1_SE1 : bit                              ;-- effec s = d(p-1)
signal HZ_SDW0_SE0 : bit                              ;-- effec s = d(p-2)
signal HZ_SDW0_SE1 : bit                              ;-- effec s = d(p-2)
signal HZ_SDW1_SE0 : bit                              ;-- effec s = d(p-2)
signal HZ_SDW1_SE1 : bit                              ;-- effec s = d(p-2)

signal HZ_TDE0_SE1 : bit                              ;-- effec t = d(p  )
signal HZ_TDE1_SE0 : bit                              ;-- effec t = d(p  )
signal HZ_TDM0_SE0 : bit                              ;-- effec t = d(p-1)
signal HZ_TDM0_SE1 : bit                              ;-- effec t = d(p-1)
signal HZ_TDM1_SE0 : bit                              ;-- effec t = d(p-1)
signal HZ_TDM1_SE1 : bit                              ;-- effec t = d(p-1)
signal HZ_TDW0_SE0 : bit                              ;-- effec t = d(p-2)
signal HZ_TDW0_SE1 : bit                              ;-- effec t = d(p-2)
signal HZ_TDW1_SE0 : bit                              ;-- effec t = d(p-2)
signal HZ_TDW1_SE1 : bit                              ;-- effec t = d(p-2)

signal HZ_DDW0_SW1 : bit                              ;-- effec d = d(p  )
signal HZ_DDW1_SW0 : bit                              ;-- effec d = d(p  )

signal PRHZSM0_SD0 : bit                              ;-- prior hazard
signal PRHZSM1_SD0 : bit                              ;-- prior hazard
signal PRHZSM0_SD1 : bit                              ;-- prior hazard
signal PRHZSM1_SD1 : bit                              ;-- prior hazard

signal PRHZTM0_SD0 : bit                              ;-- prior hazard
signal PRHZTM1_SD0 : bit                              ;-- prior hazard
signal PRHZTM0_SD1 : bit                              ;-- prior hazard
signal PRHZTM1_SD1 : bit                              ;-- prior hazard

signal PRHZSW0_SD0 : bit                              ;-- prior hazard
signal PRHZSW1_SD0 : bit                              ;-- prior hazard
signal PRHZSW0_SD1 : bit                              ;-- prior hazard
signal PRHZSW1_SD1 : bit                              ;-- prior hazard

signal PRHZTW0_SD0 : bit                              ;-- prior hazard
signal PRHZTW1_SD0 : bit                              ;-- prior hazard
signal PRHZTW0_SD1 : bit                              ;-- prior hazard
signal PRHZTW1_SD1 : bit                              ;-- prior hazard

signal HAZARDS_SD0 : bit                              ;-- hazards
signal HAZARDS_SD1 : bit                              ;-- hazards
signal HAZARDS_SE0 : bit                              ;-- hazards
signal HAZARDS_SE1 : bit                              ;-- hazards
signal HAZARDS_SM0 : bit                              ;-- hazards
signal HAZARDS_SM1 : bit                              ;-- hazards
signal HAZARDS_SW0 : bit                              ;-- hazards
signal HAZARDS_SW1 : bit                              ;-- hazards

signal CPYCRED_SD0 : bit                              ;-- copying credit
signal CPYCRED_SD1 : bit                              ;-- copying credit
signal CPYCRED_SM0 : bit                              ;-- copying credit
signal CPYCRED_SM1 : bit                              ;-- copying credit

signal WBADIA_XE0  : bit                              ;-- write bad inst adr
signal WBADIA_XE1  : bit                              ;-- write bad inst adr
signal WBADIA_XMA  : bit                              ;-- write bad inst adr
signal WBADDA_XM0  : bit                              ;-- write bad data adr
signal WBADDA_XM1  : bit                              ;-- write bad data adr

signal BADVADR_RXA : reg_vector (31 downto 0) register;-- bad virtual adr reg

signal GLBMSK_XXA  : bit                              ;-- global    it mask
signal ITMASK_XXA  : bit_vector ( 7 downto 0)         ;-- individul it mask

signal SWINT_XMA   : bit_vector ( 1 downto 0)         ;-- sw interrupt (mtc0)
signal SWINTRQ_XMA : bit_vector ( 1 downto 0)         ;-- sw interrupt rqst

signal IT_XXA      : bit_vector ( 5 downto 0)         ;-- external interrupts
signal HWINTRQ_XXA : bit_vector ( 5 downto 0)         ;-- hw interrupt rqst
signal INTRQ_XXA   : bit                              ;-- interrupt rqst

signal BDSLOT_XI0  : bit                              ;-- branch delayed slot
signal BDSLOT_XI1  : bit                              ;-- branch delayed slot
signal BDSLOT_RI0  : reg_bit                  register;-- branch delayed slot
signal BDSLOT_RI1  : reg_bit                  register;-- branch delayed slot
signal BDSLOT_XD0  : bit                              ;-- branch delayed slot
signal BDSLOT_XD1  : bit                              ;-- branch delayed slot
signal BDSLOT_RD0  : reg_bit                  register;-- branch delayed slot
signal BDSLOT_RD1  : reg_bit                  register;-- branch delayed slot
signal BDSLOT_XEA  : bit                              ;-- branch delayed slot
signal BDSLOT_RE0  : reg_bit                  register;-- branch delayed slot
signal BDSLOT_RE1  : reg_bit                  register;-- branch delayed slot

signal ILLGINS_XD0 : bit                              ;-- unknown instruction
signal ILLGINS_XD1 : bit                              ;-- unknown instruction
signal ILLGINS_RD0 : reg_bit                  register;-- unknown instruction
signal ILLGINS_RD1 : reg_bit                  register;-- unknown instruction
signal ILLGINS_RE0 : reg_bit                  register;-- unknown instruction
signal ILLGINS_RE1 : reg_bit                  register;-- unknown instruction

signal C0UNUSE_XD0 : bit                              ;-- copro 0 unusable
signal C0UNUSE_XD1 : bit                              ;-- copro 0 unusable

signal C0UNUSE_RD0 : reg_bit                  register;-- copro 0 unusable
signal C0UNUSE_RD1 : reg_bit                  register;-- copro 0 unusable

signal C0UNUSE_RE0 : reg_bit                  register;-- copro 0 unusable
signal C0UNUSE_RE1 : reg_bit                  register;-- copro 0 unusable

signal IAMALGN_XEA : bit                              ;-- inst adr miss algn
signal IAMALGN_XE0 : bit                              ;-- inst adr miss algn
signal IAMALGN_XE1 : bit                              ;-- inst adr miss algn
signal IAMALGN_RE0 : reg_bit                  register;-- inst adr miss algn
signal IAMALGN_RE1 : reg_bit                  register;-- inst adr miss algn

signal IASVIOL_XEA : bit                              ;-- inst adr segm viol
signal IASVIOL_XE0 : bit                              ;-- inst adr segm viol
signal IASVIOL_XE1 : bit                              ;-- inst adr segm viol
signal IASVIOL_RE0 : reg_bit                  register;-- inst adr segm viol
signal IASVIOL_RE1 : reg_bit                  register;-- inst adr segm viol

signal IABUSER_XEA : bit                              ;-- inst adr bus error
signal IABUSER_XE0 : bit                              ;-- inst adr bus error
signal IABUSER_XE1 : bit                              ;-- inst adr bus error
signal IABUSER_RE0 : reg_bit                  register;-- inst adr bus error
signal IABUSER_RE1 : reg_bit                  register;-- inst adr bus error

signal OVERFLW_SE0 : bit                              ;-- overflow out of alu
signal OVERFLW_SE1 : bit                              ;-- overflow out of alu
signal OVR_XE0     : bit                              ;-- arith overflow exc
signal OVR_XE1     : bit                              ;-- arith overflow exc
signal OVR_RE0     : reg_bit                  register;-- arith overflow exc
signal OVR_RE1     : reg_bit                  register;-- arith overflow exc

signal SYSCALL_XE0 : bit                              ;-- sw exc (syscall)
signal SYSCALL_XE1 : bit                              ;-- sw exc (syscall)
signal SYSCALL_RE0 : reg_bit                  register;-- sw exc (syscall)
signal SYSCALL_RE1 : reg_bit                  register;-- sw exc (syscall)

signal BREAK_XE0   : bit                              ;-- sw exc (break  )
signal BREAK_XE1   : bit                              ;-- sw exc (break  )
signal BREAK_RE0   : reg_bit                  register;-- sw exc (break  )
signal BREAK_RE1   : reg_bit                  register;-- sw exc (break  )

signal DAMALGN_XM0 : bit                              ;-- data  adr miss algn
signal DAMALGN_XM1 : bit                              ;-- data  adr miss algn

signal LAMALGN_XM0 : bit                              ;-- load  adr miss algn
signal LAMALGN_XM1 : bit                              ;-- load  adr miss algn

signal SAMALGN_XM0 : bit                              ;-- store adr miss algn
signal SAMALGN_XM1 : bit                              ;-- store adr miss algn

signal DASVIOL_XM0 : bit                              ;-- data  adr segm viol
signal DASVIOL_XM1 : bit                              ;-- data  adr segm viol

signal LASVIOL_XM0 : bit                              ;-- load  adr segm viol
signal LASVIOL_XM1 : bit                              ;-- load  adr segm viol

signal SASVIOL_XM0 : bit                              ;-- store adr segm viol
signal SASVIOL_XM1 : bit                              ;-- store adr segm viol

signal PRACCES_SM0 : bit                              ;-- prior access
signal PRACCES_SM1 : bit                              ;-- prior access

signal DABUSER_XMA : bit                              ;-- data adr bus error
signal DABUSER_XM0 : bit                              ;-- data adr bus error
signal DABUSER_XM1 : bit                              ;-- data adr bus error

signal EARLYEX_XM0 : bit                              ;-- early exceptions
signal EARLYEX_XM1 : bit                              ;-- early exceptions
signal LATEEX_XMA  : bit                              ;-- late  exceptions

signal EXCRQ_XM0   : bit                              ;-- exception request
signal EXCRQ_XM1   : bit                              ;-- exception request

signal BOOTEV_XXA  : bit                              ;-- bootstrap exc vect

signal EPC_XXA     : bit_vector (31 downto 0)         ;-- exc pg counter (int)
signal EPC_XM0     : bit_vector (31 downto 0)         ;-- exc pg counter (exc)
signal EPC_XM1     : bit_vector (31 downto 0)         ;-- exc pg counter (exc)

signal WEPC_XXA    : bit                              ;-- epc write en
signal WEPC_XM0    : bit                              ;-- epc write en
signal WEPC_XM1    : bit                              ;-- epc write en
signal EPC_RXA     : reg_vector (31 downto 0) register;-- exc pg counter reg

signal PRID_RXA    : reg_vector (31 downto 0) register;-- identifier
signal RESET_RXA   : reg_bit                  register;-- synchronized reset

-- 

constant R0_RWA     : bit_vector (31 downto 0) := X"00000000" ;

constant nop_i      : bit_vector (31 downto 0) := X"00000021" ;-- addu 0,0,0
signal   nop_type   : bit_vector (24 downto 0)                ;

constant m_writ_w   : bit_vector ( 1 downto 0) := "00"        ;-- write word
constant m_writ_h   : bit_vector ( 1 downto 0) := "10"        ;-- write half
constant m_writ_b   : bit_vector ( 1 downto 0) := "11"        ;-- write byte
constant m_read_w   : bit_vector ( 1 downto 0) := "01"        ;-- read  byte

constant excphnd_a  : bit_vector (31 downto 0) := X"80000080" ;-- handler adr
constant boothnd_a  : bit_vector (31 downto 0) := X"bfc00180" ;-- handler adr
constant reset_a    : bit_vector (31 downto 0) := X"bfc00000" ;-- reset   adr

constant badvaddr_s : bit_vector ( 4 downto 0) := B"01000"    ;-- badvaddr
constant status_s   : bit_vector ( 4 downto 0) := B"01100"    ;-- status
constant cause_s    : bit_vector ( 4 downto 0) := B"01101"    ;-- cause
constant epc_s      : bit_vector ( 4 downto 0) := B"01110"    ;-- epc
constant prid_s     : bit_vector ( 4 downto 0) := B"01111"    ;-- prid

constant r_fmt_o    : bit_vector ( 3 downto 0) := B"0001"     ;-- r format
constant i_fmt_o    : bit_vector ( 3 downto 0) := B"0010"     ;-- i format
constant j_fmt_o    : bit_vector ( 3 downto 0) := B"0100"     ;-- j format
constant illgl_o    : bit_vector ( 3 downto 0) := B"1000"     ;-- illegal ins

constant d_use_st_o : bit_vector ( 3 downto 0) := "1011"      ;-- dec use st
constant d_use_s_o  : bit_vector ( 3 downto 0) := "1010"      ;-- dec use s
constant d_use_t_o  : bit_vector ( 3 downto 0) := "1001"      ;-- dec use  t
constant e_use_st_o : bit_vector ( 3 downto 0) := "0111"      ;-- exe use st
constant e_use_s_o  : bit_vector ( 3 downto 0) := "0110"      ;-- exe use s
constant e_use_t_o  : bit_vector ( 3 downto 0) := "0101"      ;-- exe use  t
constant no_use_o   : bit_vector ( 3 downto 0) := "0000"      ;-- no oper

constant o_signd_o  : bit                      := '1'         ;-- signed
constant o_usign_o  : bit                      := '0'         ;-- unsigned

constant arith_o    : bit_vector ( 2 downto 0) := B"100"      ;-- arith  oper
constant logic_o    : bit_vector ( 2 downto 0) := B"101"      ;-- logic  oper
constant shift_o    : bit_vector ( 2 downto 0) := B"110"      ;-- shift  oper
constant test_o     : bit_vector ( 2 downto 0) := B"111"      ;-- test   oper
constant toper_o    : bit_vector ( 2 downto 0) := B"001"      ;-- take t oper
constant soper_o    : bit_vector ( 2 downto 0) := B"010"      ;-- take s oper
constant ioper_o    : bit_vector ( 2 downto 0) := B"000"      ;-- no     oper

constant add_o      : bit_vector ( 1 downto 0) := B"00"       ;-- add oper
constant sub_o      : bit_vector ( 1 downto 0) := B"01"       ;-- sub oper

constant sleft_o    : bit_vector ( 1 downto 0) := B"00"       ;-- shift left
constant sright_o   : bit_vector ( 1 downto 0) := B"01"       ;-- shift right

constant or_o       : bit_vector ( 1 downto 0) := B"00"       ;-- or  oper
constant and_o      : bit_vector ( 1 downto 0) := B"01"       ;-- and oper
constant xor_o      : bit_vector ( 1 downto 0) := B"10"       ;-- xor oper
constant nor_o      : bit_vector ( 1 downto 0) := B"11"       ;-- nor oper

constant r_signd_o  : bit                      := '1'         ;-- sign   res
constant r_usign_o  : bit                      := '0'         ;-- unsign res

constant ovr_o      : bit                      := '1'         ;--    overflow
constant nov_o      : bit                      := '0'         ;-- no overflow

constant e_pdc_rd_o : bit_vector ( 2 downto 0) := B"010"      ;-- res out exe
constant e_pdc_31_o : bit_vector ( 2 downto 0) := B"011"      ;-- res out exe
constant m_pdc_rd_o : bit_vector ( 2 downto 0) := B"100"      ;-- res out mem
constant no_pdc_o   : bit_vector ( 2 downto 0) := B"000"      ;-- no result

constant nobra_o    : bit                      := '0'         ;-- no branch
constant brnch_o    : bit                      := '1'         ;-- branch

constant loadw_o    : bit_vector ( 4 downto 0) := B"10001"    ;-- load word
constant loadh_o    : bit_vector ( 4 downto 0) := B"10010"    ;-- load half
constant loadb_o    : bit_vector ( 4 downto 0) := B"10100"    ;-- load byte
constant storw_o    : bit_vector ( 4 downto 0) := B"01001"    ;-- store word
constant storh_o    : bit_vector ( 4 downto 0) := B"01010"    ;-- store half
constant storb_o    : bit_vector ( 4 downto 0) := B"01100"    ;-- store byte
constant swapw_o    : bit_vector ( 4 downto 0) := B"11001"    ;-- swap word
constant nomem_o    : bit_vector ( 4 downto 0) := B"00000"    ;-- no access

-- 

	-- ### ------------------------------------------------------ ###
	-- #   instruction set table:					#
	-- #     Opcods in lower case are MIPS R3000 instructions	#
	-- #     Opcods in upper case are application specific		#
	-- #								#
	-- #								#
	-- #   primary opcod (31 downto 26):				#
	-- #    |  0     1     2     3     4     5     6     7		#
	-- #  --+-----+-----+-----+-----+-----+-----+-----+-----+	#
	-- #  0 |speci|bcond|  j  | jal | beq | bne |blez |bgtz |	#
	-- #  1 |addi |addui|slti |sltui|andi | ori |xori | lui |	#
	-- #  2 |cop0 |  +  |  +  |  +  |     |  +  |     |     |	#
	-- #  3 |  +  |  +  |     |     |     |     |     |     |	#
	-- #  4 | lb  | lh  |  +  | lw  | lbu | lhu |  +  |SWAP |	#
	-- #  5 | sb  | sh  |  +  | sw  |     |     |  +  |     |	#
	-- #  6 |  +  |  +  |  +  |  +  |  +  |  +  |  +  |  +  |	#
	-- #  7 |  +  |  +  |  +  |  +  |  +  |  +  |  +  |  +  |	#
	-- #								#
	-- #								#
	-- # special opcod extension (5 downto 0):			#
	-- #    |  0     1     2     3     4     5     6     7		#
	-- #  --+-----+-----+-----+-----+-----+-----+-----+-----+	#
	-- #  0 | sll |     | srl | sra |sllv |     |srlv |srav |	#
	-- #  1 | jr  |jalr |     |     |sysca|break|     |SLEEP|	#
	-- #  2 |mfhi |mthi |mflo |mtlo |     |     |     |     |	#
	-- #  3 |  +  |  +  |  +  |  +  |     |     |     |     |	#
	-- #  4 | add |addu | sub |subu | and | or  | xor | nor |	#
	-- #  5 |     |     | slt |sltu |     |     |     |     |	#
	-- #  6 |     |     |     |     |  +  |  +  |  +  |  +  |	#
	-- #  7 |     |     |     |     |  +  |  +  |  +  |  +  |	#
	-- #								#
	-- #								#
	-- # bcond opcod extension (20 downto 16):			#
	-- #    |  0     1     2     3     4     5     6     7		#
	-- #  --+-----+-----+-----+-----+-----+-----+-----+-----+	#
	-- #  0 |bltz |bgez |     |     |     |     |     |     |	#
	-- #  1 |     |     |     |     |     |     |     |     |	#
	-- #  2 |bltza|bgeza|     |     |     |     |     |     |	#
	-- #  3 |     |     |     |     |     |     |     |     |	#
	-- #								#
	-- #								#
	-- # cop0 opcod extension (22, 21, 16 / 25, 24, 23):		#
	-- #    |  0     1     2     3     4     5     6     7		#
	-- #  --+-----+-----+-----+-----+-----+-----+-----+-----+	#
	-- #  0 | mf  | mt  |  +  |  +  | c0  | c0  | c0  | c0  |	#
	-- #  1 | mf  | mt  |  +  |  +  | c0  | c0  | c0  | c0  |	#
	-- #  2 |     |     |     |     | c0  | c0  | c0  | c0  |	#
	-- #  3 |     |     |     |     | c0  | c0  | c0  | c0  |	#
	-- #  4 |  +  |  +  |     |     | c0  | c0  | c0  | c0  |	#
	-- #  5 |  +  |  +  |     |     | c0  | c0  | c0  | c0  |	#
	-- #  6 |     |     |     |     | c0  | c0  | c0  | c0  |	#
	-- #  7 |     |     |     |     | c0  | c0  | c0  | c0  |	#
	-- #								#
	-- #								#
	-- # c0 cop0 extension extension (4 downto 0):			#
	-- #    |  0     1     2     3     4     5     6     7		#
	-- #  --+-----+-----+-----+-----+-----+-----+-----+-----+	#
	-- #  0 |  +  |  +  |  +  |     |     |     |  +  |     |	#
	-- #  1 |  +  |     |     |     |     |     |     |     |	#
	-- #  2 | rfe |     |     |     |     |     |     |     |	#
	-- #  3 |  +  |     |     |     |     |     |     |     |	#
	-- #								#
	-- ### ------------------------------------------------------ ###

constant special_g  : bit_vector ( 1 downto 0) := B"00"       ;-- special ins
constant bcond_g    : bit_vector ( 2 downto 0) := B"010"      ;-- bcond ins
constant cop0_g     : bit_vector ( 1 downto 0) := B"10"       ;-- copro 0
constant others_g   : bit_vector ( 1 downto 0) := B"11"       ;-- other ins

constant special_i  : bit_vector ( 5 downto 0) := B"000_000"  ;-- special
constant bcond_i    : bit_vector ( 5 downto 0) := B"000_001"  ;-- bcond
constant cop0_i     : bit_vector ( 5 downto 0) := B"010_000"  ;-- copro 0

constant add_i      : bit_vector ( 7 downto 0) := B"00_100000";-- add
constant addi_i     : bit_vector ( 7 downto 0) := B"11_001000";-- addi
constant addu_i     : bit_vector ( 7 downto 0) := B"00_100001";-- addu
constant addui_i    : bit_vector ( 7 downto 0) := B"11_001001";-- addui
constant and_i      : bit_vector ( 7 downto 0) := B"00_100100";-- and
constant andi_i     : bit_vector ( 7 downto 0) := B"11_001100";-- andi
constant beq_i      : bit_vector ( 7 downto 0) := B"11_000100";-- beq
constant bgez_i     : bit_vector ( 7 downto 0) := B"010_00001";-- bgez
constant bgezal_i   : bit_vector ( 7 downto 0) := B"010_10001";-- bgezal
constant bgtz_i     : bit_vector ( 7 downto 0) := B"11_000111";-- bgtz
constant blez_i     : bit_vector ( 7 downto 0) := B"11_000110";-- blez
constant bltz_i     : bit_vector ( 7 downto 0) := B"010_00000";-- bltz
constant bltzal_i   : bit_vector ( 7 downto 0) := B"010_10000";-- bltzal
constant bne_i      : bit_vector ( 7 downto 0) := B"11_000101";-- bne
constant break_i    : bit_vector ( 7 downto 0) := B"00_001101";-- break
constant j_i        : bit_vector ( 7 downto 0) := B"11_000010";-- j
constant jal_i      : bit_vector ( 7 downto 0) := B"11_000011";-- jal
constant jalr_i     : bit_vector ( 7 downto 0) := B"00_001001";-- jalr
constant jr_i       : bit_vector ( 7 downto 0) := B"00_001000";-- jr
constant lb_i       : bit_vector ( 7 downto 0) := B"11_100000";-- lb
constant lbu_i      : bit_vector ( 7 downto 0) := B"11_100100";-- lbu
constant lh_i       : bit_vector ( 7 downto 0) := B"11_100001";-- lh
constant lhu_i      : bit_vector ( 7 downto 0) := B"11_100101";-- lhu
constant lui_i      : bit_vector ( 7 downto 0) := B"11_001111";-- lui
constant lw_i       : bit_vector ( 7 downto 0) := B"11_100011";-- lw
constant mfc0_i     : bit_vector ( 7 downto 0) := B"10_000000";-- mfc0
constant mtc0_i     : bit_vector ( 7 downto 0) := B"10_000001";-- mtc0
constant nor_i      : bit_vector ( 7 downto 0) := B"00_100111";-- nor
constant or_i       : bit_vector ( 7 downto 0) := B"00_100101";-- or
constant ori_i      : bit_vector ( 7 downto 0) := B"11_001101";-- ori
constant rfe_i      : bit_vector ( 7 downto 0) := B"10_110000";-- rfe
constant sb_i       : bit_vector ( 7 downto 0) := B"11_101000";-- sb
constant sh_i       : bit_vector ( 7 downto 0) := B"11_101001";-- sh
constant sleep_i    : bit_vector ( 7 downto 0) := B"00_001111";-- sleep - new
constant sll_i      : bit_vector ( 7 downto 0) := B"00_000000";-- sll
constant sllv_i     : bit_vector ( 7 downto 0) := B"00_000100";-- sllv
constant slt_i      : bit_vector ( 7 downto 0) := B"00_101010";-- slt
constant slti_i     : bit_vector ( 7 downto 0) := B"11_001010";-- slti
constant sltu_i     : bit_vector ( 7 downto 0) := B"00_101011";-- sltu
constant sltui_i    : bit_vector ( 7 downto 0) := B"11_001011";-- sltui
constant srl_i      : bit_vector ( 7 downto 0) := B"00_000010";-- srl
constant srlv_i     : bit_vector ( 7 downto 0) := B"00_000110";-- srlv
constant sra_i      : bit_vector ( 7 downto 0) := B"00_000011";-- sra
constant srav_i     : bit_vector ( 7 downto 0) := B"00_000111";-- srav
constant sub_i      : bit_vector ( 7 downto 0) := B"00_100010";-- sub
constant subu_i     : bit_vector ( 7 downto 0) := B"00_100011";-- subu
constant sw_i       : bit_vector ( 7 downto 0) := B"11_101011";-- sw
constant swap_i     : bit_vector ( 7 downto 0) := B"11_100111";-- swap - new
constant syscall_i  : bit_vector ( 7 downto 0) := B"00_001100";-- syscall
constant xor_i      : bit_vector ( 7 downto 0) := B"00_100110";-- xor
constant xori_i     : bit_vector ( 7 downto 0) := B"11_001110";-- xori

constant mfhi_i     : bit_vector ( 7 downto 0) := B"00_010000";-- mfhi
constant mthi_i     : bit_vector ( 7 downto 0) := B"00_010001";-- mthi
constant mflo_i     : bit_vector ( 7 downto 0) := B"00_010010";-- mflo
constant mtlo_i     : bit_vector ( 7 downto 0) := B"00_010011";-- mtlo

--

begin

-- ### -------------------------------------------------------------- ###
-- #   internal description:						#
-- #									#
-- #   The following lines describes in details an implementation of	#
-- # a 2 level superscalar Mips R300 Risc architecture.			#
-- #									#
-- #   The description does NOT include cache memories, nor virtual to	#
-- # real address translation mechanism (virtual memory not supported).	#
-- # Also, the description contains only integer instructions excluding	#
-- # the multiply and divide instructions.				#
-- #									#
-- #   The implementation includes 32 integer registers organized as a	#
-- # register file (4 read access and 2 write access), the HI and LO	#
-- # registers (although multiply and divide are not implemented) and	#
-- # the coprocessor zero's registers: the Exception Program Counter	#
-- # (EPC), the Status Register (SR), the Cause Register (CAUSE), the	#
-- # Bad Virtual Address Register (BADVADR) and the Processor Revision	#
-- # Identifier (PRID). The other registers of the coprocessor zero are	#
-- # not implemented.							#
-- #									#
-- #   Instructions are executed in a 5 stage pipeline:			#
-- #        IFC : Instruction Fetch					#
-- #        DEC : Instruction Decode					#
-- #        EXE : Execute						#
-- #        MEM : Memory Access						#
-- #        WBK : Write Back						#
-- #									#
-- #   All instructions follows the same execution scheme: in IFC, two	#
-- # instructions are fetched from the memory and saved in a buffer (4	#
-- # places); in DEC, operands are prepared, the execution condition	#
-- # is evaluated and the next instruction address is computed; in EXE,	#
-- # the operations are performed; in MEM, the data memory is accessed	#
-- # (because of exact exception features only one access can be done	#
-- # at each MEM cycle); and in WBK, the content of the register file	#
-- # is modified.							#
-- #									#
-- #   A global pipeline control mechanism guaranties the correct	#
-- # execution of dependent instructions. The two instructions decoded	#
-- # in the DEC cycle can be launched only if they are independent.	#
-- #									#
-- #   Most of the data hazards on integer registers are resolved by	#
-- # bypasses. Data hazards on integer registers that cannot be		#
-- # resolved by bypasses produce pipeline bubbles in DEC or in EXE	#
-- # (one or two cycles). The attempt to execute two memory access	#
-- # instructions in the MEM cycle causes the second instruction be	#
-- # delayed. In the same way, if two instructions try to write in the	#
-- # same register in WBK, the second one is delayed.			#
-- #									#
-- #   Excepting the Status Register (when modified by a RFE), there is	#
-- # no dependency control mechanism on coprocessor zero's registers.	#
-- #									#
-- #   There is no dependency control mechanism on LO and HI registers	#
-- #									#
-- #   Registers are synchronized on the rising edge of the clock.	#
-- ### -------------------------------------------------------------- ###

-- ### -------------------------------------------------------------- ###
-- #   Notes:								#
-- #     Move to Coprocessor Zero (Mtc0):				#
-- #     Registers of coprocessor zero are written in MEM.		#
-- #									#
-- #     Move from Coprocessor Zero (Mfc0):				#
-- #     Registers of coprocessor zero are read    in DEC.		#
-- #									#
-- #     Move to   LO or HI (Mtlo, Mthi):				#
-- #     Registers are written in WBK.					#
-- #									#
-- #     Move from LO or HI (Mflo, Mfhi):				#
-- #     Registers are read    in DEC.					#
-- ### -------------------------------------------------------------- ###

--

	-- ### ------------------------------------------------------ ###
	-- #   check power supplies					#
	-- ### ------------------------------------------------------ ###

CHECK_POWER : assert  (((VDD and VDDP) = '1') and ((VSS or VSSP) = '0'))
              report  "missing power supply on processor"
              severity WARNING;

	-- ### ------------------------------------------------------ ###
	-- #   nop operation (should be a constant) - in case of stall	#
	-- ### ------------------------------------------------------ ###

nop_type <= r_fmt_o   & e_use_st_o & o_usign_o  & arith_o & add_o   &
            r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o ;

	-- ### ------------------------------------------------------ ###
	-- #   internal clocks						#
	-- ### ------------------------------------------------------ ###

CK_SXA <= CK;

	-- ### ------------------------------------------------------ ###
	-- #   external (hardware) interrupts:				#
	-- #     convert to positive logic				#
	-- ### ------------------------------------------------------ ###

IT_XXA <= not IT_N;

	-- ### ------------------------------------------------------ ###
	-- #   instruction address not aligned for reading two		#
	-- # instructions. This may happen after executing a successful	#
	-- # branch.							#
	-- ### ------------------------------------------------------ ###

MALGNPC_SIA <= NEXTPC_RDA (2);

	-- ### ------------------------------------------------------ ###
	-- #   read two instructions at each cycle			#
	-- #								#
	-- #     - if the instruction memory is not able to answer the	#
	-- #       request fetched instructions are not valid and are	#
	-- #       replaced by a nop.					#
	-- #								#
	-- #     - if the address is not aligned (not multiple of 8)	#
	-- #       the first fetched instruction is not valid and thus	#
	-- #       replaced by a nop					#
	-- ### ------------------------------------------------------ ###

FI_SI0   <= I (63 downto 32) when (I_FRZ = '0' and MALGNPC_SIA = '0') else
            nop_i            ;
FI_SI1   <= I (31 downto  0) when (I_FRZ = '0'                      ) else
            nop_i            ;

VFI_SI0  <= '1'              when (I_FRZ = '0' and MALGNPC_SIA = '0') else
            '0'              ;
VFI_SI1  <= '1'              when (I_FRZ = '0'                      ) else
            '0'              ;

FIPC_SI0 <= NEXTPC_RDA       ;
FIPC_SI1 <= SEQADR_SD0       when (I_FRZ = '0'                      ) else
            NEXTPC_RDA       ;

	-- ### ------------------------------------------------------ ###
	-- #   fetched instructions' order				#
	-- #								#
	-- #     the order of the fteched instructions may have to be	#
	-- #     inverted before the instructions being saved into the	#
	-- #     instruction buffer					#
	-- #								#
	-- #     P-buff : level 0 preceds 1 in the buffer (next cycle)	#
	-- #     P-inst : inst. 0 preceds 1				#
	-- #								#
	-- #     P-buff                                       P-inst	#
	-- #     ---------------------------------------------------	#
	-- #        1     saving in the same half of the        1	#
	-- #              buffer - the address is aligned		#
	-- #								#
	-- #        1     saving across the 2 halfs of the      0	#
	-- #              buffer - the address is aligned		#
	-- #								#
	-- #        1     saving in the same half of the        0	#
	-- #              buffer - the address is not aligned		#
	-- #								#
	-- #        1     saving across the 2 halfs of the      1	#
	-- #              buffer - the address is not aligned		#
	-- #								#
	-- #        0     saving in the same half of the        0	#
	-- #              buffer - the address is aligned		#
	-- #								#
	-- #        0     saving across the 2 halfs of the      1	#
	-- #              buffer - the address is aligned		#
	-- #								#
	-- #        0     saving in the same half of the        1	#
	-- #              buffer - the address is not aligned		#
	-- #								#
	-- #        0     saving across the 2 halfs of the      0	#
	-- #              buffer - the address is not aligned		#
	-- ### ------------------------------------------------------ ###

SAVSAME_SIA <= '0' when (((HOLD_SI0   = '1' and VI_RI0 = '1') or
                          (SHIFT_SI0  = '1' and VI_RI2 = '1')   ) xor
                         ((HOLD_SI1   = '1' and VI_RI1 = '1') or
                          (SHIFT_SI1  = '1' and VI_RI3 = '1')   )    ) else
               '1' ;

PRECED_SIA <=
      PRECED_RIA when ((SAVSAME_SIA xor MALGNPC_SIA) = '1' and
                       (HOLD_SI0    xor HOLD_SI1   ) = '0'    ) else
      PRECED_RIA when ((SAVSAME_SIA xor MALGNPC_SIA) = '0' and
                       (HOLD_SI0    xor HOLD_SI1   ) = '1'    ) else
  not PRECED_RIA ;

	-- ### ------------------------------------------------------ ###
	-- #   fetched instructions' order				#
	-- ### ------------------------------------------------------ ###

I_SI0   <= FI_SI0   when (PRECED_SIA = '1') else FI_SI1   ;
I_SI1   <= FI_SI1   when (PRECED_SIA = '1') else FI_SI0   ;

VI_SI0  <= VFI_SI0  when (PRECED_SIA = '1') else VFI_SI1  ;
VI_SI1  <= VFI_SI1  when (PRECED_SIA = '1') else VFI_SI0  ;

PC_SI0  <= FIPC_SI0 when (PRECED_SIA = '1') else FIPC_SI1 ;
PC_SI1  <= FIPC_SI1 when (PRECED_SIA = '1') else FIPC_SI0 ;

	-- ### ------------------------------------------------------ ###
	-- #   new instructions read					#
	-- ### ------------------------------------------------------ ###

IREAD_SIA <= not I_FRZ when ((SHIFT_SI2 = '1' or VI_RI2 = '0') and
                             (SHIFT_SI3 = '1' or VI_RI3 = '0')    ) else
             '0'       ;

	-- ### ------------------------------------------------------ ###
	-- #  exceptions detected during the Instruction Fetch cycle:	#
	-- #								#
	-- #     - Instruction Address Bus Error (this exception is	#
	-- #       reported in the Execute cycle since it is relative	#
	-- #       to the instruction that has computed the address).	#
	-- #								#
	-- #     - Instruction Address Miss Aligned (this exception is	#
	-- #       reported in the Execute cycle since it is relative	#
	-- #       to the instruction that has computed the address)	#
	-- #								#
	-- #     - Instruction Address Violating System Space (this	#
	-- #       exception is reported in the Execute cycle since it	#
	-- #       is relative to the instruction that has computed the	#
	-- #       address). The current mode is extracted from the	#
	-- #       Status register. In the case of a Restore From	#
	-- #       Exception (Rfe) instruction modifying the Status	#
	-- #       register, the old mode is taken into account		#
	-- #       (anticipating the execution of the Rfe).		#
	-- #								#
	-- #   These exceptions are considered to be caused by the	#
	-- #   branch instruction if there is any prensent in the	#
	-- #   Execute cycle. Otherwise, the exception is attributed	#
	-- #   to the first instruction in the Execute cycle.		#
	-- ### ------------------------------------------------------ ###

MODE_XXA <= NEXTSR_RXA (3) when (OPCOD_SD0 = rfe_i and PRECED_RIA = '1') else
            NEXTSR_RXA (3) when (OPCOD_SD1 = rfe_i and PRECED_RIA = '0') else
            NEXTSR_RXA (3) when (OPCOD_RD0 = rfe_i                     ) else
            NEXTSR_RXA (3) when (OPCOD_RD1 = rfe_i                     ) else
            NEXTSR_RXA (3) when (OPCOD_RE0 = rfe_i                     ) else
            NEXTSR_RXA (3) when (OPCOD_RE1 = rfe_i                     ) else
            NEXTSR_RXA (1) ;

IABUSER_XEA <= not I_BERR_N;
IAMALGN_XEA <= NEXTPC_RDA ( 1) or  NEXTPC_RDA (0);
IASVIOL_XEA <= NEXTPC_RDA (31) and MODE_XXA      ;

IABUSER_XE0 <= IABUSER_XEA  when (I_BRNCH_SE0 = '1'                     ) else
               IABUSER_XEA  when (I_BRNCH_SE1 = '0' and PRECED_RDA = '1') else
               '0'          ;
IABUSER_XE1 <= IABUSER_XEA  when (I_BRNCH_SE1 = '1'                     ) else
               IABUSER_XEA  when (I_BRNCH_SE0 = '0' and PRECED_RDA = '0') else
               '0'          ;

IAMALGN_XE0 <= IAMALGN_XEA  when (I_BRNCH_SE0 = '1'                     ) else
               IAMALGN_XEA  when (I_BRNCH_SE1 = '0' and PRECED_RDA = '1') else
               '0'          ;
IAMALGN_XE1 <= IAMALGN_XEA  when (I_BRNCH_SE1 = '1'                     ) else
               IAMALGN_XEA  when (I_BRNCH_SE0 = '0' and PRECED_RDA = '0') else
               '0'          ;

IASVIOL_XE0 <= IASVIOL_XEA  when (I_BRNCH_SE0 = '1'                     ) else
               IASVIOL_XEA  when (I_BRNCH_SE1 = '0' and PRECED_RDA = '1') else
               '0'          ;
IASVIOL_XE1 <= IASVIOL_XEA  when (I_BRNCH_SE1 = '1'                     ) else
               IASVIOL_XEA  when (I_BRNCH_SE0 = '0' and PRECED_RDA = '0') else
               '0'          ;

	-- ### ------------------------------------------------------ ###
	-- #   extract the opcode from the instruction buffer (first	#
	-- # level)							#
	-- ### ------------------------------------------------------ ###

with I_RI0 (25) select
COP0_SD0  <= cop0_g & '0' & I_RI0 (22 downto 21) &
                      '0' & I_RI0 (24 downto 23)   when '0'   ,
             cop0_g & '1' & I_RI0 ( 4 downto  0)   when others;

with I_RI0 (31 downto 26) select
OPCOD_SD0 <= special_g    & I_RI0 ( 5 downto  0)   when special_i,
             bcond_g      & I_RI0 (20 downto 16)   when bcond_i  ,
             COP0_SD0                              when cop0_i   ,
             others_g     & I_RI0 (31 downto 26)   when others   ;

	-- ### ------------------------------------------------------ ###
	-- #   extract the opcode from the instruction buffer (second	#
	-- # level)							#
	-- ### ------------------------------------------------------ ###

with I_RI1 (25) select
COP0_SD1  <= cop0_g & '0' & I_RI1 (22 downto 21) &
                      '0' & I_RI1 (24 downto 23)   when '0'   ,
             cop0_g & '1' & I_RI1 ( 4 downto  0)   when others;

with I_RI1 (31 downto 26) select
OPCOD_SD1 <= special_g    & I_RI1 ( 5 downto  0)   when special_i,
             bcond_g      & I_RI1 (20 downto 16)   when bcond_i  ,
             COP0_SD1                              when cop0_i   ,
             others_g     & I_RI1 (31 downto 26)   when others   ;

	-- ### ------------------------------------------------------ ###
	-- #   decode the instruction's opcode (first  level)		#
	-- #								#
	-- #     - instruction format              4 bits (24 - 21)	#
	-- #     - source operands usage           4 bits (20 - 17)	#
	-- #     - signed/unsigned source operands 1 bit  (     16)	#
	-- #     - operation type                  3 bits (15 - 13)	#
	-- #     - operation                       2 bits (12 - 11)	#
	-- #     - signed/unsigned result          1 bit  (     10)	#
	-- #     - overflow detection              1 bit  (      9)	#
	-- #     - which stage produces the result 3 bits ( 8 -  6)	#
	-- #     - type of instruction (branch)    1 bit  (      5)	#
	-- #     - type of memory access           5 bits ( 4 -  0)	#
	-- ### ------------------------------------------------------ ###

with OPCOD_SD0 select
I_TYPE_SD0 <=
  r_fmt_o   & e_use_st_o & o_signd_o  & arith_o & add_o    &
  r_signd_o & ovr_o      & e_pdc_rd_o & nobra_o & nomem_o     when add_i    ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_signd_o & ovr_o      & e_pdc_rd_o & nobra_o & nomem_o     when addi_i   ,

  r_fmt_o   & e_use_st_o & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when addu_i   ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when addui_i  ,

  r_fmt_o   & e_use_st_o & o_usign_o  & logic_o & and_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when and_i    ,

  i_fmt_o   & e_use_s_o  & o_usign_o  & logic_o & and_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when andi_i   ,

  i_fmt_o   & d_use_st_o & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when beq_i    ,

  i_fmt_o   & d_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when blez_i   ,

  i_fmt_o   & d_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when bgez_i   ,

  i_fmt_o   & d_use_s_o  & o_signd_o  & ioper_o & add_o    &
  r_usign_o & nov_o      & e_pdc_31_o & brnch_o & nomem_o     when bgezal_i ,

  i_fmt_o   & d_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when bgtz_i   ,

  i_fmt_o   & d_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when bltz_i   ,

  i_fmt_o   & d_use_s_o  & o_signd_o  & ioper_o & add_o    &
  r_usign_o & nov_o      & e_pdc_31_o & brnch_o & nomem_o     when bltzal_i ,

  i_fmt_o   & d_use_st_o & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when bne_i    ,

  r_fmt_o   & no_use_o   & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when break_i  ,

  j_fmt_o   & no_use_o   & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when j_i      ,

  j_fmt_o   & no_use_o   & o_signd_o  & ioper_o & add_o    &
  r_signd_o & nov_o      & e_pdc_31_o & brnch_o & nomem_o     when jal_i    ,

  r_fmt_o   & d_use_s_o  & o_signd_o  & ioper_o & add_o    &
  r_signd_o & nov_o      & e_pdc_rd_o & brnch_o & nomem_o     when jalr_i   ,

  r_fmt_o   & d_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when jr_i     ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & m_pdc_rd_o & nobra_o & loadb_o     when lb_i     ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & m_pdc_rd_o & nobra_o & loadb_o     when lbu_i    ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & m_pdc_rd_o & nobra_o & loadh_o     when lh_i     ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & m_pdc_rd_o & nobra_o & loadh_o     when lhu_i    ,

  i_fmt_o   & no_use_o   & o_signd_o  & ioper_o & add_o    &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when lui_i    ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & m_pdc_rd_o & nobra_o & loadw_o     when lw_i     ,

  i_fmt_o   & no_use_o   & o_signd_o  & ioper_o & add_o    &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when mfc0_i   ,

  r_fmt_o   & no_use_o   & o_signd_o  & ioper_o & add_o    &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when mflo_i   ,

  r_fmt_o   & no_use_o   & o_signd_o  & ioper_o & add_o    &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when mfhi_i   ,

  r_fmt_o   & e_use_t_o  & o_signd_o  & toper_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when mtc0_i   ,

  r_fmt_o   & d_use_s_o  & o_signd_o  & soper_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when mthi_i   ,

  r_fmt_o   & d_use_s_o  & o_signd_o  & soper_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when mtlo_i   ,

  r_fmt_o   & e_use_st_o & o_usign_o  & logic_o & nor_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when nor_i    ,

  r_fmt_o   & e_use_st_o & o_usign_o  & logic_o & or_o     &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when or_i     ,

  i_fmt_o   & e_use_s_o  & o_usign_o  & logic_o & or_o     &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when ori_i    ,

  r_fmt_o   & no_use_o   & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when rfe_i    ,

  i_fmt_o   & e_use_st_o & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & storb_o     when sb_i     ,

  i_fmt_o   & e_use_st_o & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & storh_o     when sh_i     ,

  r_fmt_o   & no_use_o   & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when sleep_i  ,

  r_fmt_o   & e_use_st_o & o_signd_o  & shift_o & sleft_o  &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when sllv_i   ,

  r_fmt_o   & e_use_t_o  & o_signd_o  & shift_o & sleft_o  &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when sll_i    ,

  r_fmt_o   & e_use_st_o & o_signd_o  & test_o  & sub_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when slt_i    ,

  r_fmt_o   & e_use_st_o & o_signd_o  & test_o  & sub_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when sltu_i   ,

  r_fmt_o   & e_use_t_o  & o_signd_o  & shift_o & sright_o &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when sra_i    ,

  r_fmt_o   & e_use_st_o & o_signd_o  & shift_o & sright_o &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when srav_i   ,

  r_fmt_o   & e_use_t_o  & o_signd_o  & shift_o & sright_o &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when srl_i    ,

  r_fmt_o   & e_use_st_o & o_signd_o  & shift_o & sright_o &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when srlv_i   ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & test_o  & sub_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when sltui_i  ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & test_o  & sub_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when slti_i   ,

  r_fmt_o   & e_use_st_o & o_signd_o  & arith_o & sub_o    &
  r_signd_o & ovr_o      & e_pdc_rd_o & nobra_o & nomem_o     when sub_i    ,

  r_fmt_o   & e_use_st_o & o_signd_o  & arith_o & sub_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when subu_i   ,

  i_fmt_o   & e_use_st_o & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & storw_o     when sw_i     ,

  i_fmt_o   & e_use_st_o & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & m_pdc_rd_o & nobra_o & swapw_o     when swap_i   ,

  r_fmt_o   & no_use_o   & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when syscall_i,

  r_fmt_o   & e_use_st_o & o_usign_o  & logic_o & xor_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when xor_i    ,

  i_fmt_o   & e_use_s_o  & o_usign_o  & logic_o & xor_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when xori_i   ,

  illgl_o   & no_use_o   & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when others   ;

I_ILLG_SD0  <= I_TYPE_SD0 (24)                   ;
I_JFMT_SD0  <= I_TYPE_SD0 (23)                   ;
I_IFMT_SD0  <= I_TYPE_SD0 (22)                   ;
I_RFMT_SD0  <= I_TYPE_SD0 (21)                   ;
I_DUSE_SD0  <= I_TYPE_SD0 (20)                   ;
I_READS_SD0 <= I_TYPE_SD0 (18)                   ;
I_READT_SD0 <= I_TYPE_SD0 (17)                   ;
I_OSGND_SD0 <= I_TYPE_SD0 (16)                   ;
I_WRITE_SD0 <= I_TYPE_SD0 ( 8) or I_TYPE_SD0 ( 7);
I_WRT31_SD0 <= I_TYPE_SD0 ( 6)                   ;
I_BRNCH_SD0 <= I_TYPE_SD0 ( 5)                   ;

I_EUSE_SE0  <= I_TYPE_RD0 (19)                   ;
I_IFMT_SE0  <= I_TYPE_RD0 (22)                   ;
I_READS_SE0 <= I_TYPE_RD0 (18)                   ;
I_READT_SE0 <= I_TYPE_RD0 (17)                   ;
I_OPER_SE0  <= I_TYPE_RD0 (15 downto 13)         ;
I_LOGIC_SE0 <= I_TYPE_RD0 (12 downto 11)         ;
I_SUB_SE0   <= I_TYPE_RD0 (11)                   ;
I_RIGHT_SE0 <= I_TYPE_RD0 (11)                   ;
I_RSGND_SE0 <= I_TYPE_RD0 (10)                   ;
I_OVRF_SE0  <= I_TYPE_RD0 ( 9)                   ;
I_MPDC_SE0  <= I_TYPE_RD0 ( 8)                   ;
I_EPDC_SE0  <= I_TYPE_RD0 ( 7)                   ;
I_WRITE_SE0 <= I_TYPE_RD0 ( 8) or I_TYPE_RD0 ( 7);
I_BRNCH_SE0 <= I_TYPE_RD0 ( 5)                   ;

I_MPDC_SM0  <= I_TYPE_RE0 ( 8)                   ;
I_WRITE_SM0 <= I_TYPE_RE0 ( 8) or I_TYPE_RE0 ( 7);
I_BRNCH_SM0 <= I_TYPE_RE0 ( 5)                   ;
I_LOAD_SM0  <= I_TYPE_RE0 ( 4)                   ;
I_STOR_SM0  <= I_TYPE_RE0 ( 3)                   ;
I_BYTE_SM0  <= I_TYPE_RE0 ( 2)                   ;
I_HALF_SM0  <= I_TYPE_RE0 ( 1)                   ;
I_WORD_SM0  <= I_TYPE_RE0 ( 0)                   ;

I_WRITE_SW0 <= I_TYPE_RM0 ( 8) or I_TYPE_RM0 ( 7);

	-- ### ------------------------------------------------------ ###
	-- #   decode the second instruction's opcode			#
	-- #								#
	-- #     - instruction format              4 bits (24 - 21)	#
	-- #     - source operands usage           4 bits (20 - 17)	#
	-- #     - signed/unsigned source operands 1 bit  (     16)	#
	-- #     - operation type                  3 bits (15 - 13)	#
	-- #     - operation                       2 bits (12 - 11)	#
	-- #     - signed/unsigned result          1 bit  (     10)	#
	-- #     - overflow detection              1 bit  (      9)	#
	-- #     - which stage produces the result 3 bits ( 8 -  6)	#
	-- #     - type of instruction (branch)    1 bit  (      5)	#
	-- #     - type of memory access           5 bits ( 4 -  0)	#
	-- ### ------------------------------------------------------ ###

with OPCOD_SD1 select
I_TYPE_SD1 <=
  r_fmt_o   & e_use_st_o & o_signd_o  & arith_o & add_o    &
  r_signd_o & ovr_o      & e_pdc_rd_o & nobra_o & nomem_o     when add_i    ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_signd_o & ovr_o      & e_pdc_rd_o & nobra_o & nomem_o     when addi_i   ,

  r_fmt_o   & e_use_st_o & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when addu_i   ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when addui_i  ,

  r_fmt_o   & e_use_st_o & o_usign_o  & logic_o & and_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when and_i    ,

  i_fmt_o   & e_use_s_o  & o_usign_o  & logic_o & and_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when andi_i   ,

  i_fmt_o   & d_use_st_o & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when beq_i    ,

  i_fmt_o   & d_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when blez_i   ,

  i_fmt_o   & d_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when bgez_i   ,

  i_fmt_o   & d_use_s_o  & o_signd_o  & ioper_o & add_o    &
  r_usign_o & nov_o      & e_pdc_31_o & brnch_o & nomem_o     when bgezal_i ,

  i_fmt_o   & d_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when bgtz_i   ,

  i_fmt_o   & d_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when bltz_i   ,

  i_fmt_o   & d_use_s_o  & o_signd_o  & ioper_o & add_o    &
  r_usign_o & nov_o      & e_pdc_31_o & brnch_o & nomem_o     when bltzal_i ,

  i_fmt_o   & d_use_st_o & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when bne_i    ,

  r_fmt_o   & no_use_o   & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when break_i  ,

  j_fmt_o   & no_use_o   & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when j_i      ,

  j_fmt_o   & no_use_o   & o_signd_o  & ioper_o & add_o    &
  r_signd_o & nov_o      & e_pdc_31_o & brnch_o & nomem_o     when jal_i    ,

  r_fmt_o   & d_use_s_o  & o_signd_o  & ioper_o & add_o    &
  r_signd_o & nov_o      & e_pdc_rd_o & brnch_o & nomem_o     when jalr_i   ,

  r_fmt_o   & d_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & brnch_o & nomem_o     when jr_i     ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & m_pdc_rd_o & nobra_o & loadb_o     when lb_i     ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & m_pdc_rd_o & nobra_o & loadb_o     when lbu_i    ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & m_pdc_rd_o & nobra_o & loadh_o     when lh_i     ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_usign_o & nov_o      & m_pdc_rd_o & nobra_o & loadh_o     when lhu_i    ,

  i_fmt_o   & no_use_o   & o_signd_o  & ioper_o & add_o    &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when lui_i    ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & m_pdc_rd_o & nobra_o & loadw_o     when lw_i     ,

  i_fmt_o   & no_use_o   & o_signd_o  & ioper_o & add_o    &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when mfc0_i   ,

  r_fmt_o   & no_use_o   & o_signd_o  & ioper_o & add_o    &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when mflo_i   ,

  r_fmt_o   & no_use_o   & o_signd_o  & ioper_o & add_o    &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when mfhi_i   ,

  r_fmt_o   & e_use_t_o  & o_signd_o  & toper_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when mtc0_i   ,

  r_fmt_o   & d_use_s_o  & o_signd_o  & soper_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when mthi_i   ,

  r_fmt_o   & d_use_s_o  & o_signd_o  & soper_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when mtlo_i   ,

  r_fmt_o   & e_use_st_o & o_usign_o  & logic_o & nor_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when nor_i    ,

  r_fmt_o   & e_use_st_o & o_usign_o  & logic_o & or_o     &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when or_i     ,

  i_fmt_o   & e_use_s_o  & o_usign_o  & logic_o & or_o     &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when ori_i    ,

  r_fmt_o   & no_use_o   & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when rfe_i    ,

  i_fmt_o   & e_use_st_o & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & storb_o     when sb_i     ,

  i_fmt_o   & e_use_st_o & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & storh_o     when sh_i     ,

  r_fmt_o   & no_use_o   & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when sleep_i  ,

  r_fmt_o   & e_use_st_o & o_signd_o  & shift_o & sleft_o  &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when sllv_i   ,

  r_fmt_o   & e_use_t_o  & o_signd_o  & shift_o & sleft_o  &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when sll_i    ,

  r_fmt_o   & e_use_st_o & o_signd_o  & test_o  & sub_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when slt_i    ,

  r_fmt_o   & e_use_st_o & o_signd_o  & test_o  & sub_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when sltu_i   ,

  r_fmt_o   & e_use_t_o  & o_signd_o  & shift_o & sright_o &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when sra_i    ,

  r_fmt_o   & e_use_st_o & o_signd_o  & shift_o & sright_o &
  r_signd_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when srav_i   ,

  r_fmt_o   & e_use_t_o  & o_signd_o  & shift_o & sright_o &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when srl_i    ,

  r_fmt_o   & e_use_st_o & o_signd_o  & shift_o & sright_o &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when srlv_i   ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & test_o  & sub_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when sltui_i  ,

  i_fmt_o   & e_use_s_o  & o_signd_o  & test_o  & sub_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when slti_i   ,

  r_fmt_o   & e_use_st_o & o_signd_o  & arith_o & sub_o    &
  r_signd_o & ovr_o      & e_pdc_rd_o & nobra_o & nomem_o     when sub_i    ,

  r_fmt_o   & e_use_st_o & o_signd_o  & arith_o & sub_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when subu_i   ,

  i_fmt_o   & e_use_st_o & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & storw_o     when sw_i     ,

  i_fmt_o   & e_use_st_o & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & m_pdc_rd_o & nobra_o & swapw_o     when swap_i   ,

  r_fmt_o   & no_use_o   & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when syscall_i,

  r_fmt_o   & e_use_st_o & o_usign_o  & logic_o & xor_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when xor_i    ,

  i_fmt_o   & e_use_s_o  & o_usign_o  & logic_o & xor_o    &
  r_usign_o & nov_o      & e_pdc_rd_o & nobra_o & nomem_o     when xori_i   ,

  illgl_o   & no_use_o   & o_signd_o  & arith_o & add_o    &
  r_signd_o & nov_o      & no_pdc_o   & nobra_o & nomem_o     when others   ;

I_ILLG_SD1  <= I_TYPE_SD1 (24)                   ;
I_JFMT_SD1  <= I_TYPE_SD1 (23)                   ;
I_IFMT_SD1  <= I_TYPE_SD1 (22)                   ;
I_RFMT_SD1  <= I_TYPE_SD1 (21)                   ;
I_DUSE_SD1  <= I_TYPE_SD1 (20)                   ;
I_READS_SD1 <= I_TYPE_SD1 (18)                   ;
I_READT_SD1 <= I_TYPE_SD1 (17)                   ;
I_OSGND_SD1 <= I_TYPE_SD1 (16)                   ;
I_WRITE_SD1 <= I_TYPE_SD1 ( 8) or I_TYPE_SD1 ( 7);
I_WRT31_SD1 <= I_TYPE_SD1 ( 6)                   ;
I_BRNCH_SD1 <= I_TYPE_SD1 ( 5)                   ;

I_EUSE_SE1  <= I_TYPE_RD1 (19)                   ;
I_IFMT_SE1  <= I_TYPE_RD1 (22)                   ;
I_READS_SE1 <= I_TYPE_RD1 (18)                   ;
I_READT_SE1 <= I_TYPE_RD1 (17)                   ;
I_OPER_SE1  <= I_TYPE_RD1 (15 downto 13)         ;
I_LOGIC_SE1 <= I_TYPE_RD1 (12 downto 11)         ;
I_SUB_SE1   <= I_TYPE_RD1 (11)                   ;
I_RIGHT_SE1 <= I_TYPE_RD1 (11)                   ;
I_RSGND_SE1 <= I_TYPE_RD1 (10)                   ;
I_OVRF_SE1  <= I_TYPE_RD1 ( 9)                   ;
I_MPDC_SE1  <= I_TYPE_RD1 ( 8)                   ;
I_EPDC_SE1  <= I_TYPE_RD1 ( 7)                   ;
I_WRITE_SE1 <= I_TYPE_RD1 ( 8) or I_TYPE_RD1 ( 7);
I_BRNCH_SE1 <= I_TYPE_RD1 ( 5)                   ;

I_MPDC_SM1  <= I_TYPE_RE1 ( 8)                   ;
I_WRITE_SM1 <= I_TYPE_RE1 ( 8) or I_TYPE_RE1 ( 7);
I_BRNCH_SM1 <= I_TYPE_RE1 ( 5)                   ;
I_LOAD_SM1  <= I_TYPE_RE1 ( 4)                   ;
I_STOR_SM1  <= I_TYPE_RE1 ( 3)                   ;
I_BYTE_SM1  <= I_TYPE_RE1 ( 2)                   ;
I_HALF_SM1  <= I_TYPE_RE1 ( 1)                   ;
I_WORD_SM1  <= I_TYPE_RE1 ( 0)                   ;

I_WRITE_SW1 <= I_TYPE_RM1 ( 8) or I_TYPE_RM1 ( 7);

	-- ### ------------------------------------------------------ ###
	-- #   if the instruction in Instruction Decode is a branch,	#
	-- # the next instruction is the delayed slot			#
	-- ### ------------------------------------------------------ ###

BDSLOT_XD0 <= BDSLOT_RI0  when (PRECED_RIA = '1') else I_BRNCH_SD1 ;
BDSLOT_XD1 <= BDSLOT_RI1  when (PRECED_RIA = '0') else I_BRNCH_SD0 ;

BDSLOT_XI0 <= I_BRNCH_SD1 when (PRECED_RIA = '1') else '0'         ;
BDSLOT_XI1 <= I_BRNCH_SD0 when (PRECED_RIA = '0') else '0'         ;

	-- ### ------------------------------------------------------ ###
	-- #   extract special destination registers number from the	#
	-- # instruction (first  level).				#
	-- #								#
	-- #   extract source and destination registers number from the	#
	-- # instruction. Destination register number is set to zero	#
	-- # when not used (first  level).				#
	-- ### ------------------------------------------------------ ###

COP0D_SD0 <= I_RI0 (15 downto 11);

RS_SD0    <= I_RI0 (25 downto 21);
RT_SD0    <= I_RI0 (20 downto 16);

RD_SD0 <= B"11111"             when ((I_WRITE_SD0 and I_WRT31_SD0) = '1') else
          I_RI0 (15 downto 11) when ((I_WRITE_SD0 and I_RFMT_SD0 ) = '1') else
          I_RI0 (20 downto 16) when ((I_WRITE_SD0 and I_IFMT_SD0 ) = '1') else
          B"00000"             ;

	-- ### ------------------------------------------------------ ###
	-- #   extract special destination registers number from the	#
	-- # instruction (second level).				#
	-- #								#
	-- #   extract source and destination registers number from the	#
	-- # instruction. Destination register number is set to zero	#
	-- # when not used (second level).				#
	-- ### ------------------------------------------------------ ###

COP0D_SD1 <= I_RI1 (15 downto 11);

RS_SD1    <= I_RI1 (25 downto 21);
RT_SD1    <= I_RI1 (20 downto 16);

RD_SD1 <= B"11111"             when ((I_WRITE_SD1 and I_WRT31_SD1) = '1') else
          I_RI1 (15 downto 11) when ((I_WRITE_SD1 and I_RFMT_SD1 ) = '1') else
          I_RI1 (20 downto 16) when ((I_WRITE_SD1 and I_IFMT_SD1 ) = '1') else
          B"00000"             ;

	-- ### ------------------------------------------------------ ###
	-- #   read the instruction's source registers from the		#
	-- # register bank (first  level)				#
	-- ### ------------------------------------------------------ ###

with RS_SD0 select
S_SD0 (31 downto 0) <= R0_RWA   when B"00000",
                       R1_RWA   when B"00001",
                       R2_RWA   when B"00010",
                       R3_RWA   when B"00011",
                       R4_RWA   when B"00100",
                       R5_RWA   when B"00101",
                       R6_RWA   when B"00110",
                       R7_RWA   when B"00111",
                       R8_RWA   when B"01000",
                       R9_RWA   when B"01001",
                       R10_RWA  when B"01010",
                       R11_RWA  when B"01011",
                       R12_RWA  when B"01100",
                       R13_RWA  when B"01101",
                       R14_RWA  when B"01110",
                       R15_RWA  when B"01111",
                       R16_RWA  when B"10000",
                       R17_RWA  when B"10001",
                       R18_RWA  when B"10010",
                       R19_RWA  when B"10011",
                       R20_RWA  when B"10100",
                       R21_RWA  when B"10101",
                       R22_RWA  when B"10110",
                       R23_RWA  when B"10111",
                       R24_RWA  when B"11000",
                       R25_RWA  when B"11001",
                       R26_RWA  when B"11010",
                       R27_RWA  when B"11011",
                       R28_RWA  when B"11100",
                       R29_RWA  when B"11101",
                       R30_RWA  when B"11110",
                       R31_RWA  when B"11111";

with RT_SD0 select
T_SD0 (31 downto 0) <= R0_RWA   when B"00000",
                       R1_RWA   when B"00001",
                       R2_RWA   when B"00010",
                       R3_RWA   when B"00011",
                       R4_RWA   when B"00100",
                       R5_RWA   when B"00101",
                       R6_RWA   when B"00110",
                       R7_RWA   when B"00111",
                       R8_RWA   when B"01000",
                       R9_RWA   when B"01001",
                       R10_RWA  when B"01010",
                       R11_RWA  when B"01011",
                       R12_RWA  when B"01100",
                       R13_RWA  when B"01101",
                       R14_RWA  when B"01110",
                       R15_RWA  when B"01111",
                       R16_RWA  when B"10000",
                       R17_RWA  when B"10001",
                       R18_RWA  when B"10010",
                       R19_RWA  when B"10011",
                       R20_RWA  when B"10100",
                       R21_RWA  when B"10101",
                       R22_RWA  when B"10110",
                       R23_RWA  when B"10111",
                       R24_RWA  when B"11000",
                       R25_RWA  when B"11001",
                       R26_RWA  when B"11010",
                       R27_RWA  when B"11011",
                       R28_RWA  when B"11100",
                       R29_RWA  when B"11101",
                       R30_RWA  when B"11110",
                       R31_RWA  when B"11111";

	-- ### ------------------------------------------------------ ###
	-- #   read the instruction's source registers from the		#
	-- # register bank (second level)				#
	-- ### ------------------------------------------------------ ###

with RS_SD1 select
S_SD1 (31 downto 0) <= R0_RWA   when B"00000",
                       R1_RWA   when B"00001",
                       R2_RWA   when B"00010",
                       R3_RWA   when B"00011",
                       R4_RWA   when B"00100",
                       R5_RWA   when B"00101",
                       R6_RWA   when B"00110",
                       R7_RWA   when B"00111",
                       R8_RWA   when B"01000",
                       R9_RWA   when B"01001",
                       R10_RWA  when B"01010",
                       R11_RWA  when B"01011",
                       R12_RWA  when B"01100",
                       R13_RWA  when B"01101",
                       R14_RWA  when B"01110",
                       R15_RWA  when B"01111",
                       R16_RWA  when B"10000",
                       R17_RWA  when B"10001",
                       R18_RWA  when B"10010",
                       R19_RWA  when B"10011",
                       R20_RWA  when B"10100",
                       R21_RWA  when B"10101",
                       R22_RWA  when B"10110",
                       R23_RWA  when B"10111",
                       R24_RWA  when B"11000",
                       R25_RWA  when B"11001",
                       R26_RWA  when B"11010",
                       R27_RWA  when B"11011",
                       R28_RWA  when B"11100",
                       R29_RWA  when B"11101",
                       R30_RWA  when B"11110",
                       R31_RWA  when B"11111";

with RT_SD1 select
T_SD1 (31 downto 0) <= R0_RWA   when B"00000",
                       R1_RWA   when B"00001",
                       R2_RWA   when B"00010",
                       R3_RWA   when B"00011",
                       R4_RWA   when B"00100",
                       R5_RWA   when B"00101",
                       R6_RWA   when B"00110",
                       R7_RWA   when B"00111",
                       R8_RWA   when B"01000",
                       R9_RWA   when B"01001",
                       R10_RWA  when B"01010",
                       R11_RWA  when B"01011",
                       R12_RWA  when B"01100",
                       R13_RWA  when B"01101",
                       R14_RWA  when B"01110",
                       R15_RWA  when B"01111",
                       R16_RWA  when B"10000",
                       R17_RWA  when B"10001",
                       R18_RWA  when B"10010",
                       R19_RWA  when B"10011",
                       R20_RWA  when B"10100",
                       R21_RWA  when B"10101",
                       R22_RWA  when B"10110",
                       R23_RWA  when B"10111",
                       R24_RWA  when B"11000",
                       R25_RWA  when B"11001",
                       R26_RWA  when B"11010",
                       R27_RWA  when B"11011",
                       R28_RWA  when B"11100",
                       R29_RWA  when B"11101",
                       R30_RWA  when B"11110",
                       R31_RWA  when B"11111";

	-- ### ------------------------------------------------------ ###
	-- #   reading r0 as a source register ?			#
	-- ### ------------------------------------------------------ ###

SREADR0_SD0 <= '1' when (RS_SD0 = "00000") else '0' ;
SREADR0_SD1 <= '1' when (RS_SD1 = "00000") else '0' ;

TREADR0_SD0 <= '1' when (RT_SD0 = "00000") else '0' ;
TREADR0_SD1 <= '1' when (RT_SD1 = "00000") else '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   compare source registers of the current instruction	#
	-- # (first  level) with the destination register of previous	#
	-- # instructions (data hazards in Instruction Decode cycle)	#
	-- ### ------------------------------------------------------ ###

CP_SDD1_SD0 <= RS_SD0 xor RD_SD1;

CP_SDE0_SD0 <= RS_SD0 xor RD_RD0;
CP_SDE1_SD0 <= RS_SD0 xor RD_RD1;
CP_SDM0_SD0 <= RS_SD0 xor RD_RE0;
CP_SDM1_SD0 <= RS_SD0 xor RD_RE1;
CP_SDW0_SD0 <= RS_SD0 xor RD_RM0;
CP_SDW1_SD0 <= RS_SD0 xor RD_RM1;

CP_TDD1_SD0 <= RT_SD0 xor RD_SD1;

CP_TDE0_SD0 <= RT_SD0 xor RD_RD0;
CP_TDE1_SD0 <= RT_SD0 xor RD_RD1;
CP_TDM0_SD0 <= RT_SD0 xor RD_RE0;
CP_TDM1_SD0 <= RT_SD0 xor RD_RE1;
CP_TDW0_SD0 <= RT_SD0 xor RD_RM0;
CP_TDW1_SD0 <= RT_SD0 xor RD_RM1;

	-- ### ------------------------------------------------------ ###
	-- #   compare source registers of the current instruction	#
	-- # (second level) with the destination register of previous	#
	-- # instructions (data hazards in Instruction Decode cycle)	#
	-- ### ------------------------------------------------------ ###

CP_SDD0_SD1 <= RS_SD1 xor RD_SD0;

CP_SDE0_SD1 <= RS_SD1 xor RD_RD0;
CP_SDE1_SD1 <= RS_SD1 xor RD_RD1;
CP_SDM0_SD1 <= RS_SD1 xor RD_RE0;
CP_SDM1_SD1 <= RS_SD1 xor RD_RE1;
CP_SDW0_SD1 <= RS_SD1 xor RD_RM0;
CP_SDW1_SD1 <= RS_SD1 xor RD_RM1;

CP_TDD0_SD1 <= RT_SD1 xor RD_SD0;

CP_TDE0_SD1 <= RT_SD1 xor RD_RD0;
CP_TDE1_SD1 <= RT_SD1 xor RD_RD1;
CP_TDM0_SD1 <= RT_SD1 xor RD_RE0;
CP_TDM1_SD1 <= RT_SD1 xor RD_RE1;
CP_TDW0_SD1 <= RT_SD1 xor RD_RM0;
CP_TDW1_SD1 <= RT_SD1 xor RD_RM1;

	-- ### ------------------------------------------------------ ###
	-- #   effective comparisons (data hazards in Instruction	#
	-- # Decode cycle) (first  level):				#
	-- #     registers match and are effectively used (comparisons	#
	-- #     fail when r0 is used)					#
	-- ### ------------------------------------------------------ ###

HZ_SDD1_SD0 <= '1' when (CP_SDD1_SD0 = "00000" and SREADR0_SD0 = '0' and
                         I_READS_SD0 = '1'     and I_WRITE_SD1 = '1'    ) else
               '0' ;

HZ_SDE0_SD0 <= '1' when (CP_SDE0_SD0 = "00000" and SREADR0_SD0 = '0' and
                         I_READS_SD0 = '1'     and I_WRITE_SE0 = '1'    ) else
               '0' ;
HZ_SDE1_SD0 <= '1' when (CP_SDE1_SD0 = "00000" and SREADR0_SD0 = '0' and
                         I_READS_SD0 = '1'     and I_WRITE_SE1 = '1'    ) else
               '0' ;

HZ_SDM0_SD0 <= '1' when (CP_SDM0_SD0 = "00000" and SREADR0_SD0 = '0' and
                         I_READS_SD0 = '1'     and I_WRITE_SM0 = '1'    ) else
               '0' ;
HZ_SDM1_SD0 <= '1' when (CP_SDM1_SD0 = "00000" and SREADR0_SD0 = '0' and
                         I_READS_SD0 = '1'     and I_WRITE_SM1 = '1'    ) else
               '0' ;

HZ_SDW0_SD0 <= '1' when (CP_SDW0_SD0 = "00000" and SREADR0_SD0 = '0' and
                         I_READS_SD0 = '1'     and I_WRITE_SW0 = '1'    ) else
               '0' ;
HZ_SDW1_SD0 <= '1' when (CP_SDW1_SD0 = "00000" and SREADR0_SD0 = '0' and
                         I_READS_SD0 = '1'     and I_WRITE_SW1 = '1'    ) else
               '0' ;

HZ_TDD1_SD0 <= '1' when (CP_TDD1_SD0 = "00000" and TREADR0_SD0 = '0' and
                         I_READT_SD0 = '1'     and I_WRITE_SD1 = '1'    ) else
               '0' ;

HZ_TDE0_SD0 <= '1' when (CP_TDE0_SD0 = "00000" and TREADR0_SD0 = '0' and
                         I_READT_SD0 = '1'     and I_WRITE_SE0 = '1'    ) else
               '0' ;
HZ_TDE1_SD0 <= '1' when (CP_TDE1_SD0 = "00000" and TREADR0_SD0 = '0' and
                         I_READT_SD0 = '1'     and I_WRITE_SE1 = '1'    ) else
               '0' ;

HZ_TDM0_SD0 <= '1' when (CP_TDM0_SD0 = "00000" and TREADR0_SD0 = '0' and
                         I_READT_SD0 = '1'     and I_WRITE_SM0 = '1'    ) else
               '0' ;
HZ_TDM1_SD0 <= '1' when (CP_TDM1_SD0 = "00000" and TREADR0_SD0 = '0' and
                         I_READT_SD0 = '1'     and I_WRITE_SM1 = '1'    ) else
               '0' ;

HZ_TDW0_SD0 <= '1' when (CP_TDW0_SD0 = "00000" and TREADR0_SD0 = '0' and
                         I_READT_SD0 = '1'     and I_WRITE_SW0 = '1'    ) else
               '0' ;
HZ_TDW1_SD0 <= '1' when (CP_TDW1_SD0 = "00000" and TREADR0_SD0 = '0' and
                         I_READT_SD0 = '1'     and I_WRITE_SW1 = '1'    ) else
               '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   effective comparisons (data hazards in Instruction	#
	-- # Decode cycle) (second level):				#
	-- #     registers match and are effectively used (comparisons	#
	-- #     fail when r0 is used)					#
	-- ### ------------------------------------------------------ ###

HZ_SDD0_SD1 <= '1' when (CP_SDD0_SD1 = "00000" and SREADR0_SD1 = '0' and
                         I_READS_SD1 = '1'     and I_WRITE_SD0 = '1'    ) else
               '0' ;

HZ_SDE0_SD1 <= '1' when (CP_SDE0_SD1 = "00000" and SREADR0_SD1 = '0' and
                         I_READS_SD1 = '1'     and I_WRITE_SE0 = '1'    ) else
               '0' ;
HZ_SDE1_SD1 <= '1' when (CP_SDE1_SD1 = "00000" and SREADR0_SD1 = '0' and
                         I_READS_SD1 = '1'     and I_WRITE_SE1 = '1'    ) else
               '0' ;

HZ_SDM0_SD1 <= '1' when (CP_SDM0_SD1 = "00000" and SREADR0_SD1 = '0' and
                         I_READS_SD1 = '1'     and I_WRITE_SM0 = '1'    ) else
               '0' ;
HZ_SDM1_SD1 <= '1' when (CP_SDM1_SD1 = "00000" and SREADR0_SD1 = '0' and
                         I_READS_SD1 = '1'     and I_WRITE_SM1 = '1'    ) else
               '0' ;

HZ_SDW0_SD1 <= '1' when (CP_SDW0_SD1 = "00000" and SREADR0_SD1 = '0' and
                         I_READS_SD1 = '1'     and I_WRITE_SW0 = '1'    ) else
               '0' ;
HZ_SDW1_SD1 <= '1' when (CP_SDW1_SD1 = "00000" and SREADR0_SD1 = '0' and
                         I_READS_SD1 = '1'     and I_WRITE_SW1 = '1'    ) else
               '0' ;

HZ_TDD0_SD1 <= '1' when (CP_TDD0_SD1 = "00000" and TREADR0_SD1 = '0' and
                         I_READT_SD1 = '1'     and I_WRITE_SD0 = '1'    ) else
               '0' ;

HZ_TDE0_SD1 <= '1' when (CP_TDE0_SD1 = "00000" and TREADR0_SD1 = '0' and
                         I_READT_SD1 = '1'     and I_WRITE_SE0 = '1'    ) else
               '0' ;
HZ_TDE1_SD1 <= '1' when (CP_TDE1_SD1 = "00000" and TREADR0_SD1 = '0' and
                         I_READT_SD1 = '1'     and I_WRITE_SE1 = '1'    ) else
               '0' ;

HZ_TDM0_SD1 <= '1' when (CP_TDM0_SD1 = "00000" and TREADR0_SD1 = '0' and
                         I_READT_SD1 = '1'     and I_WRITE_SM0 = '1'    ) else
               '0' ;
HZ_TDM1_SD1 <= '1' when (CP_TDM1_SD1 = "00000" and TREADR0_SD1 = '0' and
                         I_READT_SD1 = '1'     and I_WRITE_SM1 = '1'    ) else
               '0' ;

HZ_TDW0_SD1 <= '1' when (CP_TDW0_SD1 = "00000" and TREADR0_SD1 = '0' and
                         I_READT_SD1 = '1'     and I_WRITE_SW0 = '1'    ) else
               '0' ;
HZ_TDW1_SD1 <= '1' when (CP_TDW1_SD1 = "00000" and TREADR0_SD1 = '0' and
                         I_READT_SD1 = '1'     and I_WRITE_SW1 = '1'    ) else
               '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   stall due to data hazards in Instruction Decode stage	#
	-- #								#
	-- #     - use of s or t operand in Instruction Decode stage	#
	-- #       when the result is produced by the previous		#
	-- #       instruction in Execute or in Memory Access stage	#
	-- #								#
	-- #     - use of s or t operand in Instruction Decode stage	#
	-- #       when the result is produced by the second previous	#
	-- #       instruction in Memory Access stage			#
	-- #								#
	-- #     - two dependent instructions in the Decode stage	#
	-- #								#
	-- #    Examples :						#
	-- #								#
	-- #      ADD  Ri, --, --          LW   Ri, --, --		#
	-- #      BEQ  Ri, --              --   --, --, --		#
	-- #                               BEQ  Ri, --			#
	-- #								#
	-- #      LW   Ri, --, --					#
	-- #      BEQ  Ri, --						#
	-- ### ------------------------------------------------------ ###

HAZARDS_SD0 <=    I_DUSE_SD0  and
               (((HZ_SDD1_SD0 or  HZ_TDD1_SD0) and not PRECED_RIA) or
                ((HZ_SDE0_SD0 or  HZ_TDE0_SD0)                   ) or
                ((HZ_SDE1_SD0 or  HZ_TDE1_SD0)                   ) or
                ((HZ_SDM0_SD0 or  HZ_TDM0_SD0) and     I_MPDC_SM0) or
                ((HZ_SDM1_SD0 or  HZ_TDM1_SD0) and     I_MPDC_SM1)   );

HAZARDS_SD1 <=    I_DUSE_SD1  and
               (((HZ_SDD0_SD1 or  HZ_TDD0_SD1) and     PRECED_RIA) or
                ((HZ_SDE0_SD1 or  HZ_TDE0_SD1)                   ) or
                ((HZ_SDE1_SD1 or  HZ_TDE1_SD1)                   ) or
                ((HZ_SDM0_SD1 or  HZ_TDM0_SD1) and     I_MPDC_SM0) or
                ((HZ_SDM1_SD1 or  HZ_TDM1_SD1) and     I_MPDC_SM1)   );

	-- ### ------------------------------------------------------ ###
	-- #   decoding the Sleep instruction. This signal is used to	#
	-- # stall the pipeline						#
	-- ### ------------------------------------------------------ ###

CPYCRED_SD0 <= '1' when (OPCOD_SD0 = sleep_i) else '0' ;
CPYCRED_SD1 <= '1' when (OPCOD_SD1 = sleep_i) else '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   prior data hazard on operands				#
	-- ### ------------------------------------------------------ ###

PRHZSM0_SD0 <=     PRECED_REA and HZ_SDM1_SD0;
PRHZSM1_SD0 <= not PRECED_REA and HZ_SDM0_SD0;

PRHZSM0_SD1 <=     PRECED_REA and HZ_SDM1_SD1;
PRHZSM1_SD1 <= not PRECED_REA and HZ_SDM0_SD1;

PRHZTM0_SD0 <=     PRECED_REA and HZ_TDM1_SD0;
PRHZTM1_SD0 <= not PRECED_REA and HZ_TDM0_SD0;

PRHZTM0_SD1 <=     PRECED_REA and HZ_TDM1_SD1;
PRHZTM1_SD1 <= not PRECED_REA and HZ_TDM0_SD1;

	-- ### ------------------------------------------------------ ###
	-- #   prior data hazard on operands				#
	-- ### ------------------------------------------------------ ###

PRHZSW0_SD0 <=     PRECED_RMA and HZ_SDW1_SD0;
PRHZSW1_SD0 <= not PRECED_RMA and HZ_SDW0_SD0;

PRHZSW0_SD1 <=     PRECED_RMA and HZ_SDW1_SD1;
PRHZSW1_SD1 <= not PRECED_RMA and HZ_SDW0_SD1;

PRHZTW0_SD0 <=     PRECED_RMA and HZ_TDW1_SD0;
PRHZTW1_SD0 <= not PRECED_RMA and HZ_TDW0_SD0;

PRHZTW0_SD1 <=     PRECED_RMA and HZ_TDW1_SD1;
PRHZTW1_SD1 <= not PRECED_RMA and HZ_TDW0_SD1;

	-- ### ------------------------------------------------------ ###
	-- #   compute effective operands (bypass) (first  level)	#
	-- ### ------------------------------------------------------ ###

SOPER_SD0 <= RES_RE0  when (HZ_SDM0_SD0 = '1' and PRHZSM0_SD0 = '0') else
             RES_RE1  when (HZ_SDM1_SD0 = '1' and PRHZSM1_SD0 = '0') else
             DATA_RM0 when (HZ_SDW0_SD0 = '1' and PRHZSW0_SD0 = '0') else
             DATA_RM1 when (HZ_SDW1_SD0 = '1' and PRHZSW1_SD0 = '0') else
             S_SD0    ;

TOPER_SD0 <= RES_RE0  when (HZ_TDM0_SD0 = '1' and PRHZTM0_SD0 = '0') else
             RES_RE1  when (HZ_TDM1_SD0 = '1' and PRHZTM1_SD0 = '0') else
             DATA_RM0 when (HZ_TDW0_SD0 = '1' and PRHZTW0_SD0 = '0') else
             DATA_RM1 when (HZ_TDW1_SD0 = '1' and PRHZTW1_SD0 = '0') else
             T_SD0    ;

	-- ### ------------------------------------------------------ ###
	-- #   compute effective operands (bypass) (second level)	#
	-- ### ------------------------------------------------------ ###

SOPER_SD1 <= RES_RE0  when (HZ_SDM0_SD1 = '1' and PRHZSM0_SD1 = '0') else
             RES_RE1  when (HZ_SDM1_SD1 = '1' and PRHZSM1_SD1 = '0') else
             DATA_RM0 when (HZ_SDW0_SD1 = '1' and PRHZSW0_SD1 = '0') else
             DATA_RM1 when (HZ_SDW1_SD1 = '1' and PRHZSW1_SD1 = '0') else
             S_SD1    ;

TOPER_SD1 <= RES_RE0  when (HZ_TDM0_SD1 = '1' and PRHZTM0_SD1 = '0') else
             RES_RE1  when (HZ_TDM1_SD1 = '1' and PRHZTM1_SD1 = '0') else
             DATA_RM0 when (HZ_TDW0_SD1 = '1' and PRHZTW0_SD1 = '0') else
             DATA_RM1 when (HZ_TDW1_SD1 = '1' and PRHZTW1_SD1 = '0') else
             T_SD1    ;

	-- ### ------------------------------------------------------ ###
	-- #   read the special register to be transfered into an	#
	-- # integer register (mfc0 instruction)			#
	-- ### ------------------------------------------------------ ###

with I_RI0 (15 downto 11) select
COP0OP_SD0 <= BADVADR_RXA   when badvaddr_s,
              NEXTSR_RXA    when status_s  ,
              EPC_RXA       when epc_s     ,
              CAUSE_RXA     when cause_s   ,
              PRID_RXA      when prid_s    ,
              X"00000000"   when others    ;

with I_RI1 (15 downto 11) select
COP0OP_SD1 <= BADVADR_RXA   when badvaddr_s,
              NEXTSR_RXA    when status_s  ,
              EPC_RXA       when epc_s     ,
              CAUSE_RXA     when cause_s   ,
              PRID_RXA      when prid_s    ,
              X"00000000"   when others    ;

	-- ### ------------------------------------------------------ ###
	-- #   link address (address where to return from sub-routine)	#
	-- ### ------------------------------------------------------ ###

LNKPC_SD0 <= PC_RI2;
LNKPC_SD1 <= PC_RI3;

	-- ### ------------------------------------------------------ ###
	-- #   first  level :						#
	-- #   compute immediate operand				#
	-- ### ------------------------------------------------------ ###

IMDSEX_SD0 <= X"FFFF" when (I_RI0 (15) = '1' and I_OSGND_SD0 = '1') else
              X"0000";

with OPCOD_SD0 select
IOPER_SD0  <= LNKPC_SD0                                 when jalr_i  ,
              LNKPC_SD0                                 when jal_i   ,
              LNKPC_SD0                                 when bltzal_i,
              LNKPC_SD0                                 when bgezal_i,
              X"000000"           & I_RI0 (13 downto 6) when sra_i   ,
              X"000000"           & I_RI0 (13 downto 6) when srl_i   ,
              X"000000"           & I_RI0 (13 downto 6) when sll_i   ,
              I_RI0 (15 downto 0) & X"0000"             when lui_i   ,
              COP0OP_SD0                                when mfc0_i  ,
              LO_RWA                                    when mflo_i  ,
              HI_RWA                                    when mfhi_i  ,
              IMDSEX_SD0          & I_RI0 (15 downto 0) when others  ;

	-- ### ------------------------------------------------------ ###
	-- #   second level :						#
	-- #   compute immediate operand				#
	-- ### ------------------------------------------------------ ###

IMDSEX_SD1 <= X"FFFF" when (I_RI1 (15) = '1' and I_OSGND_SD1 = '1') else
              X"0000";

with OPCOD_SD1 select
IOPER_SD1  <= LNKPC_SD1                                 when jalr_i  ,
              LNKPC_SD1                                 when jal_i   ,
              LNKPC_SD1                                 when bltzal_i,
              LNKPC_SD1                                 when bgezal_i,
              X"000000"           & I_RI1 (13 downto 6) when sra_i   ,
              X"000000"           & I_RI1 (13 downto 6) when srl_i   ,
              X"000000"           & I_RI1 (13 downto 6) when sll_i   ,
              I_RI1 (15 downto 0) & X"0000"             when lui_i   ,
              COP0OP_SD1                                when mfc0_i  ,
              LO_RWA                                    when mflo_i  ,
              HI_RWA                                    when mfhi_i  ,
              IMDSEX_SD1          & I_RI1 (15 downto 0) when others  ;

	-- ### ------------------------------------------------------ ###
	-- #   branch delayed slot's address				#
	-- ### ------------------------------------------------------ ###

DSPC_SD0    <= PC_RI1 when (PRECED_RIA = '1') else PC_RI3 ;
DSPC_SD1    <= PC_RI2 when (PRECED_RIA = '1') else PC_RI0 ;

	-- ### ------------------------------------------------------ ###
	-- #   next instruction address :				#
	-- #     - replace low order bits for jumps			#
	-- ### ------------------------------------------------------ ###

JMPADR_SD0 <= DSPC_SD0 (31 downto 28) & I_RI0 (25 downto 0) & B"00";
JMPADR_SD1 <= DSPC_SD1 (31 downto 28) & I_RI1 (25 downto 0) & B"00";

	-- ### ------------------------------------------------------ ###
	-- #   next instruction address :				#
	-- #     - add the offset for branch instructions		#
	-- ### ------------------------------------------------------ ###

OFFSET_SD0 <= IMDSEX_SD0 (13 downto 0) & I_RI0 (15 downto 0) & B"00";
OFFSET_SD1 <= IMDSEX_SD1 (13 downto 0) & I_RI1 (15 downto 0) & B"00";

BRAADR_SD0 <= DSPC_SD0 xor BRACRY_SD0 (31 downto 0) xor OFFSET_SD0;
BRAADR_SD1 <= DSPC_SD1 xor BRACRY_SD1 (31 downto 0) xor OFFSET_SD1;

BRACRY_SD0 (          0) <= '0';
BRACRY_SD0 (32 downto 1) <= (DSPC_SD0   and OFFSET_SD0              ) or
                            (DSPC_SD0   and BRACRY_SD0 (31 downto 0)) or
                            (OFFSET_SD0 and BRACRY_SD0 (31 downto 0))    ;

BRACRY_SD1 (          0) <= '0';
BRACRY_SD1 (32 downto 1) <= (DSPC_SD1   and OFFSET_SD1              ) or
                            (DSPC_SD1   and BRACRY_SD1 (31 downto 0)) or
                            (OFFSET_SD1 and BRACRY_SD1 (31 downto 0))    ;

	-- ### ------------------------------------------------------ ###
	-- #   next instruction address :				#
	-- #     - sequential address (current address + 4)		#
	-- ### ------------------------------------------------------ ###

SEQADR_SD0               <=  NEXTPC_RDA  xor SEQCRY_SD0  (31 downto 0)  xor
                             X"00000004" ;

SEQCRY_SD0 (          0) <= '0';
SEQCRY_SD0 (32 downto 1) <= (NEXTPC_RDA  and X"00000004"              ) or
                            (NEXTPC_RDA  and SEQCRY_SD0  (31 downto 0)) or
                            (X"00000004" and SEQCRY_SD0  (31 downto 0))   ;

	-- ### ------------------------------------------------------ ###
	-- #   next instruction address :				#
	-- #     - sequential address (current address + 8)		#
	-- ### ------------------------------------------------------ ###

SEQADR_SD1               <=  NEXTPC_RDA  xor SEQCRY_SD1  (31 downto 0)  xor
                             X"00000008" ;

SEQCRY_SD1 (          0) <= '0';
SEQCRY_SD1 (32 downto 1) <= (NEXTPC_RDA  and X"00000008"              ) or
                            (NEXTPC_RDA  and SEQCRY_SD1  (31 downto 0)) or
                            (X"00000008" and SEQCRY_SD1  (31 downto 0))   ;

	-- ### ------------------------------------------------------ ###
	-- #   next instruction address :				#
	-- #     - sequential address					#
	-- ### ------------------------------------------------------ ###

SEQADR_SDA  <= SEQADR_SD0 when (IREAD_SIA = '1' and MALGNPC_SIA = '1') else
               SEQADR_SD1 when (IREAD_SIA = '1' and MALGNPC_SIA = '0') else
               NEXTPC_RDA ;

	-- ### ------------------------------------------------------ ###
	-- #   first  level :						#
	-- #   conditional branches' condition				#
	-- #       Rs =  Rt						#
	-- #       Rs <  Rt						#
	-- #       Rs <= Rt						#
	-- ### ------------------------------------------------------ ###

S_CMP_T_SD0 <= SOPER_SD0 xor TOPER_SD0;

S_EQ_T_SD0  <= '1' when (S_CMP_T_SD0    = X"00000000"   ) else
               '0' ;

S_LT_Z_SD0  <= '1' when (SOPER_SD0 (31) =  '1'          ) else
               '0' ;

S_LE_Z_SD0  <= '1' when (SOPER_SD0 (31) =  '1'        or
                         SOPER_SD0      = X"00000000"   ) else
               '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   second level :						#
	-- #   conditional branches' condition				#
	-- #       Rs =  Rt						#
	-- #       Rs <  Rt						#
	-- #       Rs <= Rt						#
	-- ### ------------------------------------------------------ ###

S_CMP_T_SD1 <= SOPER_SD1 xor TOPER_SD1;

S_EQ_T_SD1  <= '1' when (S_CMP_T_SD1    = X"00000000"   ) else
               '0' ;

S_LT_Z_SD1  <= '1' when (SOPER_SD1 (31) =  '1'          ) else
               '0' ;

S_LE_Z_SD1  <= '1' when (SOPER_SD1 (31) =  '1'        or
                         SOPER_SD1      = X"00000000"   ) else
               '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   first  level :						#
	-- #     - true branch condition				#
	-- ### ------------------------------------------------------ ###

SUCCBRA_SD0 <=
  '1'         when ( OPCOD_SD0 = jr_i     or  OPCOD_SD0  = jalr_i    ) else
  '1'         when ( OPCOD_SD0 = j_i      or  OPCOD_SD0  = jal_i     ) else
  '1'         when ((OPCOD_SD0 = beq_i    and S_EQ_T_SD0 = '1'   ) or
                    (OPCOD_SD0 = bne_i    and S_EQ_T_SD0 = '0'   ) or
                    (OPCOD_SD0 = bltz_i   and S_LT_Z_SD0 = '1'   ) or
                    (OPCOD_SD0 = bltzal_i and S_LT_Z_SD0 = '1'   ) or
                    (OPCOD_SD0 = blez_i   and S_LE_Z_SD0 = '1'   ) or
                    (OPCOD_SD0 = bgtz_i   and S_LE_Z_SD0 = '0'   ) or
                    (OPCOD_SD0 = bgez_i   and S_LT_Z_SD0 = '0'   ) or
                    (OPCOD_SD0 = bgezal_i and S_LT_Z_SD0 = '0'   )   ) else
  '0'         ;

	-- ### ------------------------------------------------------ ###
	-- #   second level :						#
	-- #     - true branch condition				#
	-- ### ------------------------------------------------------ ###

SUCCBRA_SD1 <=
  '1'         when ( OPCOD_SD1 = jr_i     or  OPCOD_SD1  = jalr_i    ) else
  '1'         when ( OPCOD_SD1 = j_i      or  OPCOD_SD1  = jal_i     ) else
  '1'         when ((OPCOD_SD1 = beq_i    and S_EQ_T_SD1 = '1'   ) or
                    (OPCOD_SD1 = bne_i    and S_EQ_T_SD1 = '0'   ) or
                    (OPCOD_SD1 = bltz_i   and S_LT_Z_SD1 = '1'   ) or
                    (OPCOD_SD1 = bltzal_i and S_LT_Z_SD1 = '1'   ) or
                    (OPCOD_SD1 = blez_i   and S_LE_Z_SD1 = '1'   ) or
                    (OPCOD_SD1 = bgtz_i   and S_LE_Z_SD1 = '0'   ) or
                    (OPCOD_SD1 = bgez_i   and S_LT_Z_SD1 = '0'   ) or
                    (OPCOD_SD1 = bgezal_i and S_LT_Z_SD1 = '0'   )   ) else
  '0'         ;

	-- ### ------------------------------------------------------ ###
	-- #   first  level :						#
	-- #     - next instruction's address				#
	-- ### ------------------------------------------------------ ###

NEXTPC_SD0 <=
  SOPER_SD0  when ( OPCOD_SD0 = jr_i     or  OPCOD_SD0  = jalr_i    ) else
  JMPADR_SD0 when ( OPCOD_SD0 = j_i      or  OPCOD_SD0  = jal_i     ) else
  BRAADR_SD0 when ((OPCOD_SD0 = beq_i    and S_EQ_T_SD0 = '1'   ) or
                   (OPCOD_SD0 = bne_i    and S_EQ_T_SD0 = '0'   ) or
                   (OPCOD_SD0 = bltz_i   and S_LT_Z_SD0 = '1'   ) or
                   (OPCOD_SD0 = bltzal_i and S_LT_Z_SD0 = '1'   ) or
                   (OPCOD_SD0 = blez_i   and S_LE_Z_SD0 = '1'   ) or
                   (OPCOD_SD0 = bgtz_i   and S_LE_Z_SD0 = '0'   ) or
                   (OPCOD_SD0 = bgez_i   and S_LT_Z_SD0 = '0'   ) or
                   (OPCOD_SD0 = bgezal_i and S_LT_Z_SD0 = '0'   )   ) else
  SEQADR_SDA ;

	-- ### ------------------------------------------------------ ###
	-- #   second level :						#
	-- #     - next instruction's address				#
	-- ### ------------------------------------------------------ ###

NEXTPC_SD1 <=
  SOPER_SD1  when ( OPCOD_SD1 = jr_i     or  OPCOD_SD1  = jalr_i    ) else
  JMPADR_SD1 when ( OPCOD_SD1 = j_i      or  OPCOD_SD1  = jal_i     ) else
  BRAADR_SD1 when ((OPCOD_SD1 = beq_i    and S_EQ_T_SD1 = '1'   ) or
                   (OPCOD_SD1 = bne_i    and S_EQ_T_SD1 = '0'   ) or
                   (OPCOD_SD1 = bltz_i   and S_LT_Z_SD1 = '1'   ) or
                   (OPCOD_SD1 = bltzal_i and S_LT_Z_SD1 = '1'   ) or
                   (OPCOD_SD1 = blez_i   and S_LE_Z_SD1 = '1'   ) or
                   (OPCOD_SD1 = bgtz_i   and S_LE_Z_SD1 = '0'   ) or
                   (OPCOD_SD1 = bgez_i   and S_LT_Z_SD1 = '0'   ) or
                   (OPCOD_SD1 = bgezal_i and S_LT_Z_SD1 = '0'   )   ) else
  SEQADR_SDA ;

	-- ### ------------------------------------------------------ ###
	-- #   branch condition mispredicted				#
	-- ### ------------------------------------------------------ ###

MISPRED_SD0 <= SUCCBRA_SD0;
MISPRED_SD1 <= SUCCBRA_SD1;

	-- ### ------------------------------------------------------ ###
	-- #   processor's mode						#
	-- #								#
	-- #     - bypass the status register when an Rfe is being	#
	-- #       executed in the pipe					#
	-- ### ------------------------------------------------------ ###

MODE_SD0 <= NEXTSR_RXA (3) when (OPCOD_SD1 = rfe_i and PRECED_RIA = '0') else
            NEXTSR_RXA (3) when (OPCOD_RD0 = rfe_i                     ) else
            NEXTSR_RXA (3) when (OPCOD_RD1 = rfe_i                     ) else
            NEXTSR_RXA (3) when (OPCOD_RE0 = rfe_i                     ) else
            NEXTSR_RXA (3) when (OPCOD_RE1 = rfe_i                     ) else
            NEXTSR_RXA (1) ;

MODE_SD1 <= NEXTSR_RXA (3) when (OPCOD_SD0 = rfe_i and PRECED_RIA = '1') else
            NEXTSR_RXA (3) when (OPCOD_RD0 = rfe_i                     ) else
            NEXTSR_RXA (3) when (OPCOD_RD1 = rfe_i                     ) else
            NEXTSR_RXA (3) when (OPCOD_RE0 = rfe_i                     ) else
            NEXTSR_RXA (3) when (OPCOD_RE1 = rfe_i                     ) else
            NEXTSR_RXA (1) ;

	-- ### ------------------------------------------------------ ###
	-- #   exception detected during the Instruction Decode cycle	#
	-- #								#
	-- #     - illegal instruction					#
	-- ### ------------------------------------------------------ ###

ILLGINS_XD0 <= I_ILLG_SD0;
ILLGINS_XD1 <= I_ILLG_SD1;

	-- ### ------------------------------------------------------ ###
	-- #   exception detected during the Instruction Decode cycle	#
	-- #								#
	-- #     - coprocessor zero unusable				#
	-- ### ------------------------------------------------------ ###

with OPCOD_SD0 select
C0UNUSE_XD0 <= MODE_SD0 and not NEXTSR_RXA (28) when rfe_i | mfc0_i | mtc0_i ,
               '0'                              when others;
with OPCOD_SD1 select
C0UNUSE_XD1 <= MODE_SD1 and not NEXTSR_RXA (28) when rfe_i | mfc0_i | mtc0_i ,
               '0'                              when others;

	-- ### ------------------------------------------------------ ###
	-- #   reading r0 as a source register				#
	-- ### ------------------------------------------------------ ###

SREADR0_SE0 <= '1' when (RS_RD0 = "00000") else '0' ;
SREADR0_SE1 <= '1' when (RS_RD1 = "00000") else '0' ;

TREADR0_SE0 <= '1' when (RT_RD0 = "00000") else '0' ;
TREADR0_SE1 <= '1' when (RT_RD1 = "00000") else '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   compare source registers of the current instruction with	#
	-- # the destination register of previous instructions		#
	-- # (first  level)						#
	-- ### ------------------------------------------------------ ###

CP_SDE1_SE0 <= RS_RD0 xor RD_RD1;

CP_SDM0_SE0 <= RS_RD0 xor RD_RE0;
CP_SDW0_SE0 <= RS_RD0 xor RD_RM0;
CP_SDM1_SE0 <= RS_RD0 xor RD_RE1;
CP_SDW1_SE0 <= RS_RD0 xor RD_RM1;

CP_TDE1_SE0 <= RT_RD0 xor RD_RD1;

CP_TDM0_SE0 <= RT_RD0 xor RD_RE0;
CP_TDW0_SE0 <= RT_RD0 xor RD_RM0;
CP_TDM1_SE0 <= RT_RD0 xor RD_RE1;
CP_TDW1_SE0 <= RT_RD0 xor RD_RM1;

	-- ### ------------------------------------------------------ ###
	-- #   compare source registers of the current instruction with	#
	-- # the destination register of previous instructions		#
	-- # (second level)						#
	-- ### ------------------------------------------------------ ###

CP_SDE0_SE1 <= RS_RD1 xor RD_RD0;

CP_SDM0_SE1 <= RS_RD1 xor RD_RE0;
CP_SDW0_SE1 <= RS_RD1 xor RD_RM0;
CP_SDM1_SE1 <= RS_RD1 xor RD_RE1;
CP_SDW1_SE1 <= RS_RD1 xor RD_RM1;

CP_TDE0_SE1 <= RT_RD1 xor RD_RD0;

CP_TDM0_SE1 <= RT_RD1 xor RD_RE0;
CP_TDW0_SE1 <= RT_RD1 xor RD_RM0;
CP_TDM1_SE1 <= RT_RD1 xor RD_RE1;
CP_TDW1_SE1 <= RT_RD1 xor RD_RM1;

	-- ### ------------------------------------------------------ ###
	-- #   effective comparisons (first  level):			#
	-- #     fields matches and are effectively used (comparisons	#
	-- #     fail when r0 is used)					#
	-- ### ------------------------------------------------------ ###

HZ_SDE1_SE0 <= '1' when (CP_SDE1_SE0 = "00000" and SREADR0_SE0 = '0' and
                         I_READS_SE0 = '1'     and I_WRITE_SE1 = '1'    ) else
               '0' ;

HZ_SDM0_SE0 <= '1' when (CP_SDM0_SE0 = "00000" and SREADR0_SE0 = '0' and
                         I_READS_SE0 = '1'     and I_WRITE_SM0 = '1'    ) else
               '0' ;
HZ_SDM1_SE0 <= '1' when (CP_SDM1_SE0 = "00000" and SREADR0_SE0 = '0' and
                         I_READS_SE0 = '1'     and I_WRITE_SM1 = '1'    ) else
               '0' ;

HZ_SDW0_SE0 <= '1' when (CP_SDW0_SE0 = "00000" and SREADR0_SE0 = '0' and
                         I_READS_SE0 = '1'     and I_WRITE_SW0 = '1'    ) else
               '0' ;
HZ_SDW1_SE0 <= '1' when (CP_SDW1_SE0 = "00000" and SREADR0_SE0 = '0' and
                         I_READS_SE0 = '1'     and I_WRITE_SW1 = '1'    ) else
               '0' ;

HZ_TDE1_SE0 <= '1' when (CP_TDE1_SE0 = "00000" and TREADR0_SE0 = '0' and
                         I_READT_SE0 = '1'     and I_WRITE_SE1 = '1'    ) else
               '0' ;

HZ_TDM0_SE0 <= '1' when (CP_TDM0_SE0 = "00000" and TREADR0_SE0 = '0' and
                         I_READT_SE0 = '1'     and I_WRITE_SM0 = '1'    ) else
               '0' ;
HZ_TDM1_SE0 <= '1' when (CP_TDM1_SE0 = "00000" and TREADR0_SE0 = '0' and
                         I_READT_SE0 = '1'     and I_WRITE_SM1 = '1'    ) else
               '0' ;

HZ_TDW0_SE0 <= '1' when (CP_TDW0_SE0 = "00000" and TREADR0_SE0 = '0' and
                         I_READT_SE0 = '1'     and I_WRITE_SW0 = '1'    ) else
               '0' ;
HZ_TDW1_SE0 <= '1' when (CP_TDW1_SE0 = "00000" and TREADR0_SE0 = '0' and
                         I_READT_SE0 = '1'     and I_WRITE_SW1 = '1'    ) else
               '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   effective comparisons (second level):			#
	-- #     fields matches and are effectively used (comparisons	#
	-- #     fail when r0 is used)					#
	-- ### ------------------------------------------------------ ###

HZ_SDE0_SE1 <= '1' when (CP_SDE0_SE1 = "00000" and SREADR0_SE1 = '0' and
                         I_READS_SE1 = '1'     and I_WRITE_SE0 = '1'    ) else
               '0' ;

HZ_SDM0_SE1 <= '1' when (CP_SDM0_SE1 = "00000" and SREADR0_SE1 = '0' and
                         I_READS_SE1 = '1'     and I_WRITE_SM0 = '1'    ) else
               '0' ;
HZ_SDM1_SE1 <= '1' when (CP_SDM1_SE1 = "00000" and SREADR0_SE1 = '0' and
                         I_READS_SE1 = '1'     and I_WRITE_SM1 = '1'    ) else
               '0' ;

HZ_SDW0_SE1 <= '1' when (CP_SDW0_SE1 = "00000" and SREADR0_SE1 = '0' and
                         I_READS_SE1 = '1'     and I_WRITE_SW0 = '1'    ) else
               '0' ;
HZ_SDW1_SE1 <= '1' when (CP_SDW1_SE1 = "00000" and SREADR0_SE1 = '0' and
                         I_READS_SE1 = '1'     and I_WRITE_SW1 = '1'    ) else
               '0' ;

HZ_TDE0_SE1 <= '1' when (CP_TDE0_SE1 = "00000" and TREADR0_SE1 = '0' and
                         I_READT_SE1 = '1'     and I_WRITE_SE0 = '1'    ) else
               '0' ;

HZ_TDM0_SE1 <= '1' when (CP_TDM0_SE1 = "00000" and TREADR0_SE1 = '0' and
                         I_READT_SE1 = '1'     and I_WRITE_SM0 = '1'    ) else
               '0' ;
HZ_TDM1_SE1 <= '1' when (CP_TDM1_SE1 = "00000" and TREADR0_SE1 = '0' and
                         I_READT_SE1 = '1'     and I_WRITE_SM1 = '1'    ) else
               '0' ;

HZ_TDW0_SE1 <= '1' when (CP_TDW0_SE1 = "00000" and TREADR0_SE1 = '0' and
                         I_READT_SE1 = '1'     and I_WRITE_SW0 = '1'    ) else
               '0' ;
HZ_TDW1_SE1 <= '1' when (CP_TDW1_SE1 = "00000" and TREADR0_SE1 = '0' and
                         I_READT_SE1 = '1'     and I_WRITE_SW1 = '1'    ) else
               '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   stall due to data hazards in Execute stage :		#
	-- #								#
	-- #    - s or t operand used in Execute stage when the result	#
	-- #      is produced in Execute stage by a previous		#
	-- #      instruction.						#
	-- #								#
	-- #    - s or t operand used in Execute stage when the result	#
	-- #      is produced in Memory Access stage by a previous	#
	-- #      instruction.						#
	-- ### ------------------------------------------------------ ###

HAZARDS_SE0 <=    I_EUSE_SE0  and
               (((HZ_SDE1_SE0 or  HZ_TDE1_SE0) and not PRECED_RDA) or
                ((HZ_SDM0_SE0 or  HZ_TDM0_SE0) and     I_MPDC_SM0) or
                ((HZ_SDM1_SE0 or  HZ_TDM1_SE0) and     I_MPDC_SM1)   );

HAZARDS_SE1 <=    I_EUSE_SE1  and
               (((HZ_SDE0_SE1 or  HZ_TDE0_SE1) and     PRECED_RDA) or
                ((HZ_SDM0_SE1 or  HZ_TDM0_SE1) and     I_MPDC_SM0) or
                ((HZ_SDM1_SE1 or  HZ_TDM1_SE1) and     I_MPDC_SM1)   );

	-- ### ------------------------------------------------------ ###
	-- #   stall due to resource hazards in Memory Access stage	#
	-- #								#
	-- #    - a load/store instruction following a load/store	#
	-- #      instruction						#
	-- #								#
	-- #    - A Move to Coprocessor or a Return From Exception	#
	-- #      instruction following a Move to Coprocessor or a	#
	-- #      Return From Exception instruction			#
	-- ### ------------------------------------------------------ ###

HAZARDS_SM0 <= (DACCESS_SM0 and DACCESS_SM1 and not PRECED_REA) or
               (WSR_SM0     and WSR_SM1     and not PRECED_REA) or
               (WCAUSE_SM0  and WCAUSE_SM1  and not PRECED_REA)   ;

HAZARDS_SM1 <= (DACCESS_SM0 and DACCESS_SM1 and     PRECED_REA) or
               (WSR_SM0     and WSR_SM1     and     PRECED_REA) or
               (WCAUSE_SM0  and WCAUSE_SM1  and     PRECED_REA)   ;

	-- ### ------------------------------------------------------ ###
	-- #   copying credit in Memory Access stage			#
	-- ### ------------------------------------------------------ ###

CPYCRED_SM0 <= '1' when (ISTAT_RE0 = '1') else '0' ;
CPYCRED_SM1 <= '1' when (ISTAT_RE1 = '1') else '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   compare destination registers in Write Back		#
	-- #								#
	-- #   a data hazards is detected if two instructions tend to	#
	-- #   write into the same register.				#
	-- ### ------------------------------------------------------ ###

CP_DDW1_SW0 <= RD_RM0 xor RD_RM1;
CP_DDW0_SW1 <= RD_RM0 xor RD_RM1;

	-- ### ------------------------------------------------------ ###
	-- #   is the destination register r0 ?				#
	-- ### ------------------------------------------------------ ###

WRITER0_SW0 <= '1' when (RD_RM0 = "00000") else '0' ;
WRITER0_SW1 <= '1' when (RD_RM1 = "00000") else '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   data hazards in Write Back				#
	-- #     - two instructions writing into the same register	#
	-- #     - two instructions writing into LO       register	#
	-- #     - two instructions writing into HI       register	#
	-- ### ------------------------------------------------------ ###

HZ_DDW1_SW0 <= '1' when (CP_DDW1_SW0 = "00000" and WRITER0_SW0 = '0' and
                         I_WRITE_SW1 = '1'     and I_WRITE_SW0 = '1'    ) else
               '1' when (WLO_SW0     = '1'     and WLO_SW1     = '1'    ) else
               '1' when (WHI_SW0     = '1'     and WHI_SW1     = '1'    ) else
               '0' ;

HZ_DDW0_SW1 <= '1' when (CP_DDW0_SW1 = "00000" and WRITER0_SW1 = '0' and
                         I_WRITE_SW1 = '1'     and I_WRITE_SW0 = '1'    ) else
               '1' when (WLO_SW0     = '1'     and WLO_SW1     = '1'    ) else
               '1' when (WHI_SW0     = '1'     and WHI_SW1     = '1'    ) else
               '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   stall due to resource hazards in Write Back stage	#
	-- #								#
	-- #    - two instructions that modify the same register	#
	-- ### ------------------------------------------------------ ###

HAZARDS_SW0 <= HZ_DDW1_SW0 and not PRECED_RMA;
HAZARDS_SW1 <= HZ_DDW0_SW1 and     PRECED_RMA;

	-- ### ------------------------------------------------------ ###
	-- #   effective operands (bypasses) (first  level)		#
	-- ### ------------------------------------------------------ ###

SOPER_SE0 <= RES_RE0   when ( HZ_SDM0_SE0 = '1' and
                             (HZ_SDM1_SE0 = '0' or  PRECED_REA = '0')) else
             RES_RE1   when ( HZ_SDM1_SE0 = '1' and
                             (HZ_SDM0_SE0 = '0' or  PRECED_REA = '1')) else
             DATA_RM0  when ( HZ_SDW0_SE0 = '1' and
                             (HZ_SDW1_SE0 = '0' or  PRECED_RMA = '0')) else
             DATA_RM1  when ( HZ_SDW1_SE0 = '1' and
                             (HZ_SDW0_SE0 = '0' or  PRECED_RMA = '1')) else
             SOPER_RD0 ;

TOPER_SE0 <= RES_RE0   when ( HZ_TDM0_SE0 = '1' and
                             (HZ_TDM1_SE0 = '0' or  PRECED_REA = '0')) else
             RES_RE1   when ( HZ_TDM1_SE0 = '1' and
                             (HZ_TDM0_SE0 = '0' or  PRECED_REA = '1')) else
             DATA_RM0  when ( HZ_TDW0_SE0 = '1' and
                             (HZ_TDW1_SE0 = '0' or  PRECED_RMA = '0')) else
             DATA_RM1  when ( HZ_TDW1_SE0 = '1' and
                             (HZ_TDW0_SE0 = '0' or  PRECED_RMA = '1')) else
             TOPER_RD0 ;

with OPCOD_RD0 select
XOPER_SE0 <= IOPER_RD0 when  sll_i  | srl_i | sra_i,
             SOPER_SE0 when  others ;

YOPER_SE0 <= IOPER_RD0 when (I_IFMT_SE0 = '1') else
             TOPER_SE0 ;

	-- ### ------------------------------------------------------ ###
	-- #   effective operands (bypasses) (second level)		#
	-- ### ------------------------------------------------------ ###

SOPER_SE1 <= RES_RE0   when ( HZ_SDM0_SE1 = '1' and
                             (HZ_SDM1_SE1 = '0' or  PRECED_REA = '0')) else
             RES_RE1   when ( HZ_SDM1_SE1 = '1' and
                             (HZ_SDM0_SE1 = '0' or  PRECED_REA = '1')) else
             DATA_RM0  when ( HZ_SDW0_SE1 = '1' and
                             (HZ_SDW1_SE1 = '0' or  PRECED_RMA = '0')) else
             DATA_RM1  when ( HZ_SDW1_SE1 = '1' and
                             (HZ_SDW0_SE1 = '0' or  PRECED_RMA = '1')) else
             SOPER_RD1 ;

TOPER_SE1 <= RES_RE0   when ( HZ_TDM0_SE1 = '1' and
                             (HZ_TDM1_SE1 = '0' or  PRECED_REA = '0')) else
             RES_RE1   when ( HZ_TDM1_SE1 = '1' and
                             (HZ_TDM0_SE1 = '0' or  PRECED_REA = '1')) else
             DATA_RM0  when ( HZ_TDW0_SE1 = '1' and
                             (HZ_TDW1_SE1 = '0' or  PRECED_RMA = '0')) else
             DATA_RM1  when ( HZ_TDW1_SE1 = '1' and
                             (HZ_TDW0_SE1 = '0' or  PRECED_RMA = '1')) else
             TOPER_RD1 ;

with OPCOD_RD1 select
XOPER_SE1 <= IOPER_RD1 when  sll_i  | srl_i | sra_i,
             SOPER_SE1 when  others ;

YOPER_SE1 <= IOPER_RD1 when (I_IFMT_SE1 = '1') else
             TOPER_SE1 ;

	-- ### ------------------------------------------------------ ###
	-- #   operands for arithmetic operations :			#
	-- ### ------------------------------------------------------ ###

XARITH_SE0 <=     XOPER_SE0 ;
YARITH_SE0 <=     YOPER_SE0 when (I_SUB_SE0 = '0') else
              not YOPER_SE0 ;

XARITH_SE1 <=     XOPER_SE1 ;
YARITH_SE1 <=     YOPER_SE1 when (I_SUB_SE1 = '0') else
              not YOPER_SE1 ;

	-- ### ------------------------------------------------------ ###
	-- #   arithmetic result (first  level)				#
	-- ### ------------------------------------------------------ ###

RARITH_SE0               <=  XARITH_SE0 xor CARITH_SE0 (31 downto 0) xor
                             YARITH_SE0 ;

CARITH_SE0 (0)           <=  I_SUB_SE0  ;
CARITH_SE0 (32 downto 1) <= (XARITH_SE0 and YARITH_SE0 (31 downto 0)) or
                            (XARITH_SE0 and CARITH_SE0 (31 downto 0)) or
                            (YARITH_SE0 and CARITH_SE0 (31 downto 0)) ;

	-- ### ------------------------------------------------------ ###
	-- #   arithmetic result (second level)				#
	-- ### ------------------------------------------------------ ###

RARITH_SE1               <=  XARITH_SE1 xor CARITH_SE1 (31 downto 0) xor
                             YARITH_SE1 ;

CARITH_SE1 (0)           <=  I_SUB_SE1  ;
CARITH_SE1 (32 downto 1) <= (XARITH_SE1 and YARITH_SE1 (31 downto 0)) or
                            (XARITH_SE1 and CARITH_SE1 (31 downto 0)) or
                            (YARITH_SE1 and CARITH_SE1 (31 downto 0)) ;

	-- ### ------------------------------------------------------ ###
	-- #   arithmetic overflow					#
	-- ### ------------------------------------------------------ ###

OVERFLW_SE0 <= CARITH_SE0 (32) xor CARITH_SE0 (31);
OVERFLW_SE1 <= CARITH_SE1 (32) xor CARITH_SE1 (31);

 	-- ### ------------------------------------------------------ ###
	-- #   test and set unit's result (first  level)		#
	-- ### ------------------------------------------------------ ###

S_LT_T_SE0  <= '1' when ((RARITH_SE0 (31) xor OVERFLW_SE0) = '1') else
               '0' ;
S_LTU_T_SE0 <= '1' when ( CARITH_SE0 (32)                  = '0') else
               '0' ;

with OPCOD_RD0 select
SETBIT_SE0 <= S_LT_T_SE0  when slt_i  | slti_i ,
              S_LTU_T_SE0 when sltu_i | sltui_i,
              '0'         when others ;

RTEST_SE0 <= X"0000000" & B"000" & SETBIT_SE0;

 	-- ### ------------------------------------------------------ ###
	-- #   test and set unit's result (second level)		#
	-- ### ------------------------------------------------------ ###

S_LT_T_SE1  <= '1' when ((RARITH_SE1 (31) xor OVERFLW_SE1) = '1') else
               '0' ;
S_LTU_T_SE1 <= '1' when ( CARITH_SE1 (32)                  = '0') else
               '0' ;

with OPCOD_RD1 select
SETBIT_SE1 <= S_LT_T_SE1  when slt_i  | slti_i ,
              S_LTU_T_SE1 when sltu_i | sltui_i,
              '0'         when others ;

RTEST_SE1  <= X"0000000" & B"000" & SETBIT_SE1;

	-- ### ------------------------------------------------------ ###
	-- #   shifter's result (first  level)				#
	-- ### ------------------------------------------------------ ###

with (I_RIGHT_SE0 and I_RSGND_SE0 and YOPER_SE0 (31)) select
SHIFTIN_SE0 <= X"FFFFFFFF" when '1',
               X"00000000" when '0';

with XOPER_SE0 (4 downto 0) select
SHLEFT_SE0 <=
  YOPER_SE0 (31 downto 0)                               when B"00000",
  YOPER_SE0 (30 downto 0) & SHIFTIN_SE0 (31          )  when B"00001",
  YOPER_SE0 (29 downto 0) & SHIFTIN_SE0 (31 downto 30)  when B"00010",
  YOPER_SE0 (28 downto 0) & SHIFTIN_SE0 (31 downto 29)  when B"00011",
  YOPER_SE0 (27 downto 0) & SHIFTIN_SE0 (31 downto 28)  when B"00100",
  YOPER_SE0 (26 downto 0) & SHIFTIN_SE0 (31 downto 27)  when B"00101",
  YOPER_SE0 (25 downto 0) & SHIFTIN_SE0 (31 downto 26)  when B"00110",
  YOPER_SE0 (24 downto 0) & SHIFTIN_SE0 (31 downto 25)  when B"00111",
  YOPER_SE0 (23 downto 0) & SHIFTIN_SE0 (31 downto 24)  when B"01000",
  YOPER_SE0 (22 downto 0) & SHIFTIN_SE0 (31 downto 23)  when B"01001",
  YOPER_SE0 (21 downto 0) & SHIFTIN_SE0 (31 downto 22)  when B"01010",
  YOPER_SE0 (20 downto 0) & SHIFTIN_SE0 (31 downto 21)  when B"01011",
  YOPER_SE0 (19 downto 0) & SHIFTIN_SE0 (31 downto 20)  when B"01100",
  YOPER_SE0 (18 downto 0) & SHIFTIN_SE0 (31 downto 19)  when B"01101",
  YOPER_SE0 (17 downto 0) & SHIFTIN_SE0 (31 downto 18)  when B"01110",
  YOPER_SE0 (16 downto 0) & SHIFTIN_SE0 (31 downto 17)  when B"01111",
  YOPER_SE0 (15 downto 0) & SHIFTIN_SE0 (31 downto 16)  when B"10000",
  YOPER_SE0 (14 downto 0) & SHIFTIN_SE0 (31 downto 15)  when B"10001",
  YOPER_SE0 (13 downto 0) & SHIFTIN_SE0 (31 downto 14)  when B"10010",
  YOPER_SE0 (12 downto 0) & SHIFTIN_SE0 (31 downto 13)  when B"10011",
  YOPER_SE0 (11 downto 0) & SHIFTIN_SE0 (31 downto 12)  when B"10100",
  YOPER_SE0 (10 downto 0) & SHIFTIN_SE0 (31 downto 11)  when B"10101",
  YOPER_SE0 (9  downto 0) & SHIFTIN_SE0 (31 downto 10)  when B"10110",
  YOPER_SE0 (8  downto 0) & SHIFTIN_SE0 (31 downto  9)  when B"10111",
  YOPER_SE0 (7  downto 0) & SHIFTIN_SE0 (31 downto  8)  when B"11000",
  YOPER_SE0 (6  downto 0) & SHIFTIN_SE0 (31 downto  7)  when B"11001",
  YOPER_SE0 (5  downto 0) & SHIFTIN_SE0 (31 downto  6)  when B"11010",
  YOPER_SE0 (4  downto 0) & SHIFTIN_SE0 (31 downto  5)  when B"11011",
  YOPER_SE0 (3  downto 0) & SHIFTIN_SE0 (31 downto  4)  when B"11100",
  YOPER_SE0 (2  downto 0) & SHIFTIN_SE0 (31 downto  3)  when B"11101",
  YOPER_SE0 (1  downto 0) & SHIFTIN_SE0 (31 downto  2)  when B"11110",
  YOPER_SE0 (0          ) & SHIFTIN_SE0 (31 downto  1)  when B"11111";

with XOPER_SE0 (4 downto 0) select
SHRIGHT_SE0 <=
                               YOPER_SE0 (31 downto  0) when B"00000",
  SHIFTIN_SE0 (31          ) & YOPER_SE0 (31 downto  1) when B"00001",
  SHIFTIN_SE0 (31 downto 30) & YOPER_SE0 (31 downto  2) when B"00010",
  SHIFTIN_SE0 (31 downto 29) & YOPER_SE0 (31 downto  3) when B"00011",
  SHIFTIN_SE0 (31 downto 28) & YOPER_SE0 (31 downto  4) when B"00100",
  SHIFTIN_SE0 (31 downto 27) & YOPER_SE0 (31 downto  5) when B"00101",
  SHIFTIN_SE0 (31 downto 26) & YOPER_SE0 (31 downto  6) when B"00110",
  SHIFTIN_SE0 (31 downto 25) & YOPER_SE0 (31 downto  7) when B"00111",
  SHIFTIN_SE0 (31 downto 24) & YOPER_SE0 (31 downto  8) when B"01000",
  SHIFTIN_SE0 (31 downto 23) & YOPER_SE0 (31 downto  9) when B"01001",
  SHIFTIN_SE0 (31 downto 22) & YOPER_SE0 (31 downto 10) when B"01010",
  SHIFTIN_SE0 (31 downto 21) & YOPER_SE0 (31 downto 11) when B"01011",
  SHIFTIN_SE0 (31 downto 20) & YOPER_SE0 (31 downto 12) when B"01100",
  SHIFTIN_SE0 (31 downto 19) & YOPER_SE0 (31 downto 13) when B"01101",
  SHIFTIN_SE0 (31 downto 18) & YOPER_SE0 (31 downto 14) when B"01110",
  SHIFTIN_SE0 (31 downto 17) & YOPER_SE0 (31 downto 15) when B"01111",
  SHIFTIN_SE0 (31 downto 16) & YOPER_SE0 (31 downto 16) when B"10000",
  SHIFTIN_SE0 (31 downto 15) & YOPER_SE0 (31 downto 17) when B"10001",
  SHIFTIN_SE0 (31 downto 14) & YOPER_SE0 (31 downto 18) when B"10010",
  SHIFTIN_SE0 (31 downto 13) & YOPER_SE0 (31 downto 19) when B"10011",
  SHIFTIN_SE0 (31 downto 12) & YOPER_SE0 (31 downto 20) when B"10100",
  SHIFTIN_SE0 (31 downto 11) & YOPER_SE0 (31 downto 21) when B"10101",
  SHIFTIN_SE0 (31 downto 10) & YOPER_SE0 (31 downto 22) when B"10110",
  SHIFTIN_SE0 (31 downto  9) & YOPER_SE0 (31 downto 23) when B"10111",
  SHIFTIN_SE0 (31 downto  8) & YOPER_SE0 (31 downto 24) when B"11000",
  SHIFTIN_SE0 (31 downto  7) & YOPER_SE0 (31 downto 25) when B"11001",
  SHIFTIN_SE0 (31 downto  6) & YOPER_SE0 (31 downto 26) when B"11010",
  SHIFTIN_SE0 (31 downto  5) & YOPER_SE0 (31 downto 27) when B"11011",
  SHIFTIN_SE0 (31 downto  4) & YOPER_SE0 (31 downto 28) when B"11100",
  SHIFTIN_SE0 (31 downto  3) & YOPER_SE0 (31 downto 29) when B"11101",
  SHIFTIN_SE0 (31 downto  2) & YOPER_SE0 (31 downto 30) when B"11110",
  SHIFTIN_SE0 (31 downto  1) & YOPER_SE0 (31          ) when B"11111";

RSHIFT_SE0 <= SHRIGHT_SE0 when (I_RIGHT_SE0 = '1') else
              SHLEFT_SE0  ;

	-- ### ------------------------------------------------------ ###
	-- #   shifter's result (second level)				#
	-- ### ------------------------------------------------------ ###

with (I_RIGHT_SE1 and I_RSGND_SE1 and YOPER_SE1 (31)) select
SHIFTIN_SE1 <= X"FFFFFFFF" when '1',
               X"00000000" when '0';

with XOPER_SE1 (4 downto 0) select
SHLEFT_SE1 <=
  YOPER_SE1 (31 downto 0)                               when B"00000",
  YOPER_SE1 (30 downto 0) & SHIFTIN_SE1 (31          )  when B"00001",
  YOPER_SE1 (29 downto 0) & SHIFTIN_SE1 (31 downto 30)  when B"00010",
  YOPER_SE1 (28 downto 0) & SHIFTIN_SE1 (31 downto 29)  when B"00011",
  YOPER_SE1 (27 downto 0) & SHIFTIN_SE1 (31 downto 28)  when B"00100",
  YOPER_SE1 (26 downto 0) & SHIFTIN_SE1 (31 downto 27)  when B"00101",
  YOPER_SE1 (25 downto 0) & SHIFTIN_SE1 (31 downto 26)  when B"00110",
  YOPER_SE1 (24 downto 0) & SHIFTIN_SE1 (31 downto 25)  when B"00111",
  YOPER_SE1 (23 downto 0) & SHIFTIN_SE1 (31 downto 24)  when B"01000",
  YOPER_SE1 (22 downto 0) & SHIFTIN_SE1 (31 downto 23)  when B"01001",
  YOPER_SE1 (21 downto 0) & SHIFTIN_SE1 (31 downto 22)  when B"01010",
  YOPER_SE1 (20 downto 0) & SHIFTIN_SE1 (31 downto 21)  when B"01011",
  YOPER_SE1 (19 downto 0) & SHIFTIN_SE1 (31 downto 20)  when B"01100",
  YOPER_SE1 (18 downto 0) & SHIFTIN_SE1 (31 downto 19)  when B"01101",
  YOPER_SE1 (17 downto 0) & SHIFTIN_SE1 (31 downto 18)  when B"01110",
  YOPER_SE1 (16 downto 0) & SHIFTIN_SE1 (31 downto 17)  when B"01111",
  YOPER_SE1 (15 downto 0) & SHIFTIN_SE1 (31 downto 16)  when B"10000",
  YOPER_SE1 (14 downto 0) & SHIFTIN_SE1 (31 downto 15)  when B"10001",
  YOPER_SE1 (13 downto 0) & SHIFTIN_SE1 (31 downto 14)  when B"10010",
  YOPER_SE1 (12 downto 0) & SHIFTIN_SE1 (31 downto 13)  when B"10011",
  YOPER_SE1 (11 downto 0) & SHIFTIN_SE1 (31 downto 12)  when B"10100",
  YOPER_SE1 (10 downto 0) & SHIFTIN_SE1 (31 downto 11)  when B"10101",
  YOPER_SE1 (9  downto 0) & SHIFTIN_SE1 (31 downto 10)  when B"10110",
  YOPER_SE1 (8  downto 0) & SHIFTIN_SE1 (31 downto  9)  when B"10111",
  YOPER_SE1 (7  downto 0) & SHIFTIN_SE1 (31 downto  8)  when B"11000",
  YOPER_SE1 (6  downto 0) & SHIFTIN_SE1 (31 downto  7)  when B"11001",
  YOPER_SE1 (5  downto 0) & SHIFTIN_SE1 (31 downto  6)  when B"11010",
  YOPER_SE1 (4  downto 0) & SHIFTIN_SE1 (31 downto  5)  when B"11011",
  YOPER_SE1 (3  downto 0) & SHIFTIN_SE1 (31 downto  4)  when B"11100",
  YOPER_SE1 (2  downto 0) & SHIFTIN_SE1 (31 downto  3)  when B"11101",
  YOPER_SE1 (1  downto 0) & SHIFTIN_SE1 (31 downto  2)  when B"11110",
  YOPER_SE1 (0          ) & SHIFTIN_SE1 (31 downto  1)  when B"11111";

with XOPER_SE1 (4 downto 0) select
SHRIGHT_SE1 <=
                               YOPER_SE1 (31 downto  0) when B"00000",
  SHIFTIN_SE1 (31          ) & YOPER_SE1 (31 downto  1) when B"00001",
  SHIFTIN_SE1 (31 downto 30) & YOPER_SE1 (31 downto  2) when B"00010",
  SHIFTIN_SE1 (31 downto 29) & YOPER_SE1 (31 downto  3) when B"00011",
  SHIFTIN_SE1 (31 downto 28) & YOPER_SE1 (31 downto  4) when B"00100",
  SHIFTIN_SE1 (31 downto 27) & YOPER_SE1 (31 downto  5) when B"00101",
  SHIFTIN_SE1 (31 downto 26) & YOPER_SE1 (31 downto  6) when B"00110",
  SHIFTIN_SE1 (31 downto 25) & YOPER_SE1 (31 downto  7) when B"00111",
  SHIFTIN_SE1 (31 downto 24) & YOPER_SE1 (31 downto  8) when B"01000",
  SHIFTIN_SE1 (31 downto 23) & YOPER_SE1 (31 downto  9) when B"01001",
  SHIFTIN_SE1 (31 downto 22) & YOPER_SE1 (31 downto 10) when B"01010",
  SHIFTIN_SE1 (31 downto 21) & YOPER_SE1 (31 downto 11) when B"01011",
  SHIFTIN_SE1 (31 downto 20) & YOPER_SE1 (31 downto 12) when B"01100",
  SHIFTIN_SE1 (31 downto 19) & YOPER_SE1 (31 downto 13) when B"01101",
  SHIFTIN_SE1 (31 downto 18) & YOPER_SE1 (31 downto 14) when B"01110",
  SHIFTIN_SE1 (31 downto 17) & YOPER_SE1 (31 downto 15) when B"01111",
  SHIFTIN_SE1 (31 downto 16) & YOPER_SE1 (31 downto 16) when B"10000",
  SHIFTIN_SE1 (31 downto 15) & YOPER_SE1 (31 downto 17) when B"10001",
  SHIFTIN_SE1 (31 downto 14) & YOPER_SE1 (31 downto 18) when B"10010",
  SHIFTIN_SE1 (31 downto 13) & YOPER_SE1 (31 downto 19) when B"10011",
  SHIFTIN_SE1 (31 downto 12) & YOPER_SE1 (31 downto 20) when B"10100",
  SHIFTIN_SE1 (31 downto 11) & YOPER_SE1 (31 downto 21) when B"10101",
  SHIFTIN_SE1 (31 downto 10) & YOPER_SE1 (31 downto 22) when B"10110",
  SHIFTIN_SE1 (31 downto  9) & YOPER_SE1 (31 downto 23) when B"10111",
  SHIFTIN_SE1 (31 downto  8) & YOPER_SE1 (31 downto 24) when B"11000",
  SHIFTIN_SE1 (31 downto  7) & YOPER_SE1 (31 downto 25) when B"11001",
  SHIFTIN_SE1 (31 downto  6) & YOPER_SE1 (31 downto 26) when B"11010",
  SHIFTIN_SE1 (31 downto  5) & YOPER_SE1 (31 downto 27) when B"11011",
  SHIFTIN_SE1 (31 downto  4) & YOPER_SE1 (31 downto 28) when B"11100",
  SHIFTIN_SE1 (31 downto  3) & YOPER_SE1 (31 downto 29) when B"11101",
  SHIFTIN_SE1 (31 downto  2) & YOPER_SE1 (31 downto 30) when B"11110",
  SHIFTIN_SE1 (31 downto  1) & YOPER_SE1 (31          ) when B"11111";

RSHIFT_SE1 <= SHRIGHT_SE1 when (I_RIGHT_SE1 = '1') else
              SHLEFT_SE1  ;

	-- ### ------------------------------------------------------ ###
	-- #   logic unit's result (first  level)			#
	-- ### ------------------------------------------------------ ###

with I_LOGIC_SE0 select
RLOGIC_SE0 <= XOPER_SE0 and YOPER_SE0 when and_o ,
              XOPER_SE0 or  YOPER_SE0 when or_o  ,
              XOPER_SE0 nor YOPER_SE0 when nor_o ,
              XOPER_SE0 xor YOPER_SE0 when others;

	-- ### ------------------------------------------------------ ###
	-- #   logic unit's result (second level)			#
	-- ### ------------------------------------------------------ ###

with I_LOGIC_SE1 select
RLOGIC_SE1 <= XOPER_SE1 and YOPER_SE1 when and_o ,
              XOPER_SE1 or  YOPER_SE1 when or_o  ,
              XOPER_SE1 nor YOPER_SE1 when nor_o ,
              XOPER_SE1 xor YOPER_SE1 when others;

	-- ### ------------------------------------------------------ ###
	-- #   result out of alu (first  level)				#
	-- ### ------------------------------------------------------ ###

with I_OPER_SE0 select
RES_SE0  <= RARITH_SE0   when arith_o,
            RLOGIC_SE0   when logic_o,
            RSHIFT_SE0   when shift_o,
            RTEST_SE0    when test_o ,
            TOPER_SE0    when toper_o,
            SOPER_SE0    when soper_o,
            IOPER_RD0    when others ;

	-- ### ------------------------------------------------------ ###
	-- #   result out of alu (second level)				#
	-- ### ------------------------------------------------------ ###

with I_OPER_SE1 select
RES_SE1  <= RARITH_SE1   when arith_o,
            RLOGIC_SE1   when logic_o,
            RSHIFT_SE1   when shift_o,
            RTEST_SE1    when test_o ,
            TOPER_SE1    when toper_o,
            SOPER_SE1    when soper_o,
            IOPER_RD1    when others ;

	-- ### ------------------------------------------------------ ###
	-- #  exceptions detected during the Execute cycle:		#
	-- #								#
	-- #   - exceptions relative to the instruction address (in	#
	-- #     such a case the instruction address is saved into the	#
	-- #     Bad Virtual Address register)				#
	-- ### ------------------------------------------------------ ###

WBADIA_XE0 <= IABUSER_XE0 or IAMALGN_XE0 or IASVIOL_XE0;
WBADIA_XE1 <= IABUSER_XE1 or IAMALGN_XE1 or IASVIOL_XE1;

	-- ### ------------------------------------------------------ ###
	-- #   exceptions relative to the instruction address (in such	#
	-- # a case the instruction address is saved into the Bad	#
	-- # Virtual Address register)					#
	-- ### ------------------------------------------------------ ###

WBADIA_XMA <= IASVIOL_RE0 or IASVIOL_RE1 or
              IAMALGN_RE0 or IAMALGN_RE1 or
              IABUSER_RE0 or IABUSER_RE1   ;

	-- ### ------------------------------------------------------ ###
	-- #  exceptions detected during the Execute cycle:		#
	-- #								#
	-- #     - executing a Break or a Syscall instruction		#
	-- ### ------------------------------------------------------ ###

BREAK_XE0   <= '1' when (OPCOD_RD0 = break_i  ) else
               '0' ;
BREAK_XE1   <= '1' when (OPCOD_RD1 = break_i  ) else
               '0' ;

SYSCALL_XE0 <= '1' when (OPCOD_RD0 = syscall_i) else
               '0' ;
SYSCALL_XE1 <= '1' when (OPCOD_RD1 = syscall_i) else
               '0' ;

	-- ### ------------------------------------------------------ ###
	-- #  exceptions detected during the Execute cycle:		#
	-- #								#
	-- #     - detecting an overflow				#
	-- ### ------------------------------------------------------ ###

OVR_XE0     <= OVERFLW_SE0 and I_OVRF_SE0;
OVR_XE1     <= OVERFLW_SE1 and I_OVRF_SE1;

	-- ### ------------------------------------------------------ ###
	-- #   data memory access control lines:			#
	-- #								#
	-- #       L  : I_LOAD_SM.					#
	-- #       S  : I_STOR_SM.					#
	-- #       F  : first swap access				#
	-- #								#
	-- #       W  : WRITE_SM.					#
	-- #       A  : DACCESS_SM.					#
	-- #       LK : DLOCK_SM.					#
	-- #								#
	-- #       L   S   F         operation              W   A  LK	#
	-- #     +---+---+---+----------------------------+---+---+---+	#
	-- #     | 1 | 0 | 0 | load  instruction          | 0 | 1 | 0 |	#
	-- #     | 0 | 1 | 0 | store instruction          | 1 | 1 | 0 |	#
	-- #     | 1 | 1 | 1 | first  swap access (load)  | 0 | 1 | 1 |	#
	-- #     | 1 | 1 | 0 | second swap access (store) | 1 | 1 | 0 |	#
	-- #     | 0 | 0 | 0 | no access                  | 0 | 0 | 0 |	#
	-- #								#
	-- ### ------------------------------------------------------ ###

WRITE_SM0   <= '0'        when (OPCOD_RE0 = swap_i and ISTAT_RE0 = '1') else
               I_STOR_SM0 ;
WRITE_SM1   <= '0'        when (OPCOD_RE1 = swap_i and ISTAT_RE1 = '1') else
               I_STOR_SM1 ;

DLOCK_SM0   <= '1'        when (OPCOD_RE0 = swap_i and ISTAT_RE0 = '1') else
               '0'        ;
DLOCK_SM1   <= '1'        when (OPCOD_RE1 = swap_i and ISTAT_RE1 = '1') else
               '0'        ;

DACCESS_SM0 <= I_STOR_SM0 or I_LOAD_SM0 ;
DACCESS_SM1 <= I_STOR_SM1 or I_LOAD_SM1 ;

	-- ### ------------------------------------------------------ ###
	-- #   data memory access control lines:			#
	-- #   access type 						#
	-- ### ------------------------------------------------------ ###

DATYPE_SM0 <= m_writ_w when ((I_WORD_SM0 and WRITE_SM0) = '1') else
              m_writ_h when ((I_HALF_SM0 and WRITE_SM0) = '1') else
              m_writ_b when ((I_BYTE_SM0 and WRITE_SM0) = '1') else
              m_read_w ;

DATYPE_SM1 <= m_writ_w when ((I_WORD_SM1 and WRITE_SM1) = '1') else
              m_writ_h when ((I_HALF_SM1 and WRITE_SM1) = '1') else
              m_writ_b when ((I_BYTE_SM1 and WRITE_SM1) = '1') else
              m_read_w ;

	-- ### ------------------------------------------------------ ###
	-- #   a data has been read from the memory			#
	-- ### ------------------------------------------------------ ###

DREAD_SM0 <= DACCESS_SM0 and (not WRITE_SM0);
DREAD_SM1 <= DACCESS_SM1 and (not WRITE_SM1);

	-- ### ------------------------------------------------------ ###
	-- #   define the destination register number for the register	#
	-- # file:							#
	-- #								#
	-- #   - the destination register number, is the one defined	#
	-- #     by the instruction, except during the last cycle of	#
	-- #     Swap (store cycle).					#
	-- ### ------------------------------------------------------ ###

RD_SM0 <= "00000"  when (OPCOD_RE0 = swap_i and ISTAT_RE0 = '0') else
           RD_RE0  ;
RD_SM1 <= "00000"  when (OPCOD_RE1 = swap_i and ISTAT_RE1 = '0') else
           RD_RE1  ;

	-- ### ------------------------------------------------------ ###
	-- #   select bytes that are to be read from or written into	#
	-- # the memory							#
	-- ### ------------------------------------------------------ ###

with (I_BYTE_SM0 & I_HALF_SM0 & I_WORD_SM0 & RES_RE0 (1 downto 0)) select
BYTSEL_SM0 <= B"0001" when B"100_00",
              B"0010" when B"100_01",
              B"0100" when B"100_10",
              B"1000" when B"100_11",
              B"0011" when B"010_00",
              B"1100" when B"010_10",
              B"1111" when B"001_00",
              B"0000" when others   ;

with (I_BYTE_SM1 & I_HALF_SM1 & I_WORD_SM1 & RES_RE1 (1 downto 0)) select
BYTSEL_SM1 <= B"0001" when B"100_00",
              B"0010" when B"100_01",
              B"0100" when B"100_10",
              B"1000" when B"100_11",
              B"0011" when B"010_00",
              B"1100" when B"010_10",
              B"1111" when B"001_00",
              B"0000" when others   ;

	-- ### ------------------------------------------------------ ###
	-- #   align data read from the memory				#
	-- ### ------------------------------------------------------ ###

REDDAT_SM0 <=             D_IN (31 downto  0) when (BYTSEL_SM0 (0) = '1') else
              X"00"     & D_IN (31 downto  8) when (BYTSEL_SM0 (1) = '1') else
              X"0000"   & D_IN (31 downto 16) when (BYTSEL_SM0 (2) = '1') else
              X"000000" & D_IN (31 downto 24) ;

REDDAT_SM1 <=             D_IN (31 downto  0) when (BYTSEL_SM1 (0) = '1') else
              X"00"     & D_IN (31 downto  8) when (BYTSEL_SM1 (1) = '1') else
              X"0000"   & D_IN (31 downto 16) when (BYTSEL_SM1 (2) = '1') else
              X"000000" & D_IN (31 downto 24) ;

	-- ### ------------------------------------------------------ ###
	-- #   extend the sign when loading a byte or a half word in	#
	-- # signed mode						#
	-- ### ------------------------------------------------------ ###

BSEXT_SM0 <= X"FFFFFF" when (REDDAT_SM0 ( 7) = '1' and OPCOD_RE0 = lb_i) else
             X"000000" ;
BSEXT_SM1 <= X"FFFFFF" when (REDDAT_SM1 ( 7) = '1' and OPCOD_RE1 = lb_i) else
             X"000000" ;

HSEXT_SM0 <= X"FFFF"   when (REDDAT_SM0 (15) = '1' and OPCOD_RE0 = lh_i) else
             X"0000"   ;
HSEXT_SM1 <= X"FFFF"   when (REDDAT_SM1 (15) = '1' and OPCOD_RE1 = lh_i) else
             X"0000"   ;

with OPCOD_RE0 select
DATA_SM0 <= REDDAT_SM0                            when lw_i   | swap_i,
            BSEXT_SM0  & REDDAT_SM0 ( 7 downto 0) when lb_i   | lbu_i ,
            HSEXT_SM0  & REDDAT_SM0 (15 downto 0) when lh_i   | lhu_i ,
            RES_RE0                               when others         ;
with OPCOD_RE1 select
DATA_SM1 <= REDDAT_SM1                            when lw_i   | swap_i,
            BSEXT_SM1  & REDDAT_SM1 ( 7 downto 0) when lb_i   | lbu_i ,
            HSEXT_SM1  & REDDAT_SM1 (15 downto 0) when lh_i   | lhu_i ,
            RES_RE1                               when others         ;

	-- ### ------------------------------------------------------ ###
	-- #   save the address of the branch instruction		#
	-- ### ------------------------------------------------------ ###

WREDOPC_SE0 <= I_BRNCH_SE0;
WREDOPC_SE1 <= I_BRNCH_SE1;

WREDOPC_SM0 <= I_BRNCH_SM0;
WREDOPC_SM1 <= I_BRNCH_SM1;

	-- ### ------------------------------------------------------ ###
	-- #   prior access						#
	-- ### ------------------------------------------------------ ###

PRACCES_SM0 <= not PRECED_REA and DACCESS_SM1;
PRACCES_SM1 <=     PRECED_REA and DACCESS_SM0;

	-- ### ------------------------------------------------------ ###
	-- #   exceptions detected during the Memory Access cycle:	#
	-- #								#
	-- #     - data  address bus error				#
	-- ### ------------------------------------------------------ ###

DABUSER_XMA <= not D_BERR_N;

DABUSER_XM0 <= DABUSER_XMA and DACCESS_SM0 and not PRACCES_SM0;
DABUSER_XM1 <= DABUSER_XMA and DACCESS_SM1 and not PRACCES_SM1;

	-- ### ------------------------------------------------------ ###
	-- #   exceptions detected during the Memory Access cycle:	#
	-- #								#
	-- #     - load  address miss aligned				#
	-- #     - store address miss aligned				#
	-- #     - load  address violating system space			#
	-- #     - store address violating system space			#
	-- ### ------------------------------------------------------ ###

DAMALGN_XM0 <= RES_RE0 ( 1) or RES_RE0 (0) when (I_WORD_SM0 = '1') else
               RES_RE0 ( 0)                when (I_HALF_SM0 = '1') else
               '0'                         ;
DAMALGN_XM1 <= RES_RE1 ( 1) or RES_RE1 (0) when (I_WORD_SM1 = '1') else
               RES_RE1 ( 0)                when (I_HALF_SM1 = '1') else
               '0'                         ;

LAMALGN_XM0 <= DAMALGN_XM0 and I_LOAD_SM0 and not PRACCES_SM0;
LAMALGN_XM1 <= DAMALGN_XM1 and I_LOAD_SM1 and not PRACCES_SM1;

SAMALGN_XM0 <= DAMALGN_XM0 and I_STOR_SM0 and not PRACCES_SM0;
SAMALGN_XM1 <= DAMALGN_XM1 and I_STOR_SM1 and not PRACCES_SM1;

	-- ### ------------------------------------------------------ ###
	-- #   exceptions detected during the Memory Access cycle:	#
	-- #								#
	-- #     - load  address violating system space			#
	-- #     - store address violating system space			#
	-- ### ------------------------------------------------------ ###

DASVIOL_XM0 <= RES_RE0 (31) and MODE_RE0;
DASVIOL_XM1 <= RES_RE1 (31) and MODE_RE1;

LASVIOL_XM0 <= DASVIOL_XM0 and I_LOAD_SM0 and not PRACCES_SM0;
LASVIOL_XM1 <= DASVIOL_XM1 and I_LOAD_SM1 and not PRACCES_SM1;

SASVIOL_XM0 <= DASVIOL_XM0 and I_STOR_SM0 and not PRACCES_SM0;
SASVIOL_XM1 <= DASVIOL_XM1 and I_STOR_SM1 and not PRACCES_SM1;

	-- ### ------------------------------------------------------ ###
	-- #   exceptions relative to data address (in such a case the	#
	-- # data address is saved into the Bad Virtual Address		#
	-- # register)							#
	-- ### ------------------------------------------------------ ###

WBADDA_XM0 <= SASVIOL_XM0 or LASVIOL_XM0 or
              LAMALGN_XM0 or SAMALGN_XM0 or
              DABUSER_XM0                  ;

WBADDA_XM1 <= SASVIOL_XM1 or LASVIOL_XM1 or
              LAMALGN_XM1 or SAMALGN_XM1 or
              DABUSER_XM1                  ;

	-- ### ------------------------------------------------------ ###
	-- #   prepare the data to be written into the cause register:	#
	-- #								#
	-- #     BD   : Branch Delay               (1 bit )		#
	-- #     CE   : Coprocessor Error          (1 bit )		#
	-- #     HWIP : Hardware Interrupt Pending (6 bits)		#
	-- #     SWIP : Software Interrupt Pending (2 bits)		#
	-- #     EXC  : Exception Code             (4 bits)		#
	-- #								#
	-- #     the cause register is written in the following cases	#
	-- #   (decreasing order of priority):				#
	-- #								#
	-- #                       BD    CE   HWIP   SWIP   EXC		#
	-- #   -----------------+-----+-----+------+------+-----+	#
	-- #   exception        | New | New | New  | Old  | New |	#
	-- #   interrupt        | New | New | New  | New  | New |	#
	-- #   Mtc0 instruction | Old | Old | New  | New  | Old |	#
	-- #   at each cycle    | Old | Old | New  | Old  | Old |	#
	-- #								#
	-- ### ------------------------------------------------------ ###

COPERR_XMA  <= "00";

EXCCODE_XM0 <= X"4" when ((LAMALGN_XM0  or LASVIOL_XM0 or
                           IAMALGN_RE0  or IASVIOL_RE0   ) = '1') else
               X"5" when ((SAMALGN_XM0  or SASVIOL_XM0   ) = '1') else
               X"6" when ( IABUSER_RE0                     = '1') else
               X"7" when ( DABUSER_XMA                     = '1') else
               X"8" when ( SYSCALL_RE0                     = '1') else
               X"9" when ( BREAK_RE0                       = '1') else
               X"a" when ( ILLGINS_RE0                     = '1') else
               X"b" when ( C0UNUSE_RE0                     = '1') else
               X"c" when ( OVR_RE0                         = '1') else
               X"0" ;

EXCCODE_XM1 <= X"4" when ((LAMALGN_XM1  or LASVIOL_XM1 or
                           IAMALGN_RE1  or IASVIOL_RE1   ) = '1') else
               X"5" when ((SAMALGN_XM1  or SASVIOL_XM1   ) = '1') else
               X"6" when ( IABUSER_RE1                     = '1') else
               X"7" when ( DABUSER_XMA                     = '1') else
               X"8" when ( SYSCALL_RE1                     = '1') else
               X"9" when ( BREAK_RE1                       = '1') else
               X"a" when ( ILLGINS_RE1                     = '1') else
               X"b" when ( C0UNUSE_RE1                     = '1') else
               X"c" when ( OVR_RE1                         = '1') else
               X"0" ;

	-- ### ------------------------------------------------------ ###
	-- #   prepare the data to be written into the cause register:	#
	-- #								#
	-- #     - in case of exception almost all the fileds are	#
	-- #       updated. The Branch Delayed Slot, the Coprocessor	#
	-- #       Error and the Exception Code are modified to report	#
	-- #       the processor's state. The Software Interrupt	#
	-- #       Pending remains unchanged (the Hardware Interrupts	#
	-- #       Pending is updated at each cycle).			#
	-- ### ------------------------------------------------------ ###

WCAUSE_XM0 <= EXCRQ_XM0 and (    PRECED_REA or not EXCRQ_XM1);
WCAUSE_XM1 <= EXCRQ_XM1 and (not PRECED_REA or not EXCRQ_XM0);

CAUSE_XM0  <= BDSLOT_RE0              & '0'  & COPERR_XMA  & X"000" & IT_XXA &
              CAUSE_RXA  (9 downto 8) & "00" & EXCCODE_XM0 &  "00"  ;
CAUSE_XM1  <= BDSLOT_RE1              & '0'  & COPERR_XMA  & X"000" & IT_XXA &
              CAUSE_RXA  (9 downto 8) & "00" & EXCCODE_XM1 &  "00"  ;

	-- ### ------------------------------------------------------ ###
	-- #   prepare the data to be written into the cause register:	#
	-- #								#
	-- #     - in case of interrupt all the fileds are updated.	#
	-- #       The Branch Delayed Slot, the Coprocessor Error and	#
	-- #       the Exception Code are modified to report the	#
	-- #       processor's state. The Software Interrupt Pending	#
	-- #       are modified if the instruction in Memory Access	#
	-- #       stage is a Mtc0 (ststus). (the Hardware Interrupts	#
	-- #       Pending is updated at each cycle).			#
	-- #								#
	-- #       The Branch Delayed Slot bit is set if the first	#
	-- #       unexecuted instruction is the delayed slot		#
	-- #       instruction of a branch.				#
	-- #								#
	-- #       NB: writing the Software Interrupt Pending bits is	#
	-- #           conditioned by the execution of the Mtc0		#
	-- #           instruction (KEEP_SM = '0').			#
	-- ### ------------------------------------------------------ ###

SWINT_XMA  <=
  RES_RE0   (9 downto 8) when (WCAUSE_SM0 = '1' and KEEP_SM0 = '0') else
  RES_RE1   (9 downto 8) when (WCAUSE_SM1 = '1' and KEEP_SM1 = '0') else
  CAUSE_RXA (9 downto 8) ;

BDSLOT_XEA <= BDSLOT_RD0 when (PRECED_RDA = '1') else
              BDSLOT_RD1 ;

CAUSE_XXA  <= BDSLOT_XEA & '0'  & COPERR_XMA & X"000" & IT_XXA &
              SWINT_XMA  & "00" & "0000"     &  "00"  ;

	-- ### ------------------------------------------------------ ###
	-- #   instruction writing the into the Cause register		#
	-- ### ------------------------------------------------------ ###

WCAUSE_SM0 <= '1' when (OPCOD_RE0 = mtc0_i and COP0D_RE0 = cause_s) else '0' ;
WCAUSE_SM1 <= '1' when (OPCOD_RE1 = mtc0_i and COP0D_RE1 = cause_s) else '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   prepare the data to be written into the cause register	#
	-- #								#
	-- #     - the execution of a Mtc0 instruction updates the	#
	-- #       Software Interrupt Pending bits (this case hapens	#
	-- #       when software interrupts are masked) (the Hardware	#
	-- #       Interrupt Pending is updated at each cycle).		#
	-- ### ------------------------------------------------------ ###


CAUSE_SM0  <= CAUSE_RXA (31 downto 16) & IT_XXA & RES_RE0 (9 downto 8) &
              CAUSE_RXA ( 7 downto  0) ;
CAUSE_SM1  <= CAUSE_RXA (31 downto 16) & IT_XXA & RES_RE1 (9 downto 8) &
              CAUSE_RXA ( 7 downto  0) ;

	-- ### ------------------------------------------------------ ###
	-- #   prepare the data to be written into the cause register:	#
	-- #								#
	-- #     - at each cycle, the Hardware Interrupt Pending is	#
	-- #       saved						#
	-- ### ------------------------------------------------------ ###

CAUSE_SXA  <= CAUSE_RXA (31 downto 16) & IT_XXA & CAUSE_RXA (9 downto 0);

	-- ### ------------------------------------------------------ ###
	-- #   prepare the data to be written into the status register:	#
	-- #								#
	-- #     - Rfe instruction:					#
	-- #         the old status restored into the register		#
	-- #     - Mtc0 instruction:					#
	-- #         the status register is loaded by the value of an	#
	-- #         integer register					#
	-- #								#
	-- #   write enable into the status register:			#
	-- #     - the status register is modified when executing an	#
	-- #       Rfe or an Mtc0 (move into status register).		#
	-- ### ------------------------------------------------------ ###

RSTORSR_SMA <= NEXTSR_RXA (31 downto 4) & NEXTSR_RXA (5 downto 2);

with OPCOD_RE0 select
NEXTSR_SM0  <= RSTORSR_SMA when rfe_i ,
               RES_RE0     when others;
with OPCOD_RE1 select
NEXTSR_SM1  <= RSTORSR_SMA when rfe_i ,
               RES_RE1     when others;

WSR_SM0     <= '1' when ((OPCOD_RE0 = rfe_i                          ) or
                         (OPCOD_RE0 = mtc0_i and COP0D_RE0 = status_s)   ) else
               '0' ;
WSR_SM1     <= '1' when ((OPCOD_RE1 = rfe_i                          ) or
                         (OPCOD_RE1 = mtc0_i and COP0D_RE1 = status_s)   ) else
               '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   LO and HI registers' write enable:			#
	-- #								#
	-- #     - theses registers are modified when a Move into LO or	#
	-- #       a Move into HI instruction is executed		#
	-- ### ------------------------------------------------------ ###

WLO_SW0  <= '1' when (OPCOD_RM0 = mtlo_i) else '0' ;
WLO_SW1  <= '1' when (OPCOD_RM1 = mtlo_i) else '0' ;

WHI_SW0  <= '1' when (OPCOD_RM0 = mthi_i) else '0' ;
WHI_SW1  <= '1' when (OPCOD_RM1 = mthi_i) else '0' ;

	-- ### ------------------------------------------------------ ###
	-- #   compute the next instruction address:			#
	-- #								#
	-- #    - in case of reset					#
	-- #    - in case of interrupt or exception during the bootstrap#
	-- #    - in case of interrupt or exception			#
	-- ### ------------------------------------------------------ ###

BOOTEV_XXA <= NEXTSR_RXA (22);

NEXTPC_XXA <= reset_a    when (RESET_RXA = '1'                     ) else
              boothnd_a  when (EXCRQ_XM0 = '1' and BOOTEV_XXA = '1') else
              boothnd_a  when (EXCRQ_XM1 = '1' and BOOTEV_XXA = '1') else
              boothnd_a  when (INTRQ_XXA = '1' and BOOTEV_XXA = '1') else
              excphnd_a  when (EXCRQ_XM0 = '1' and BOOTEV_XXA = '0') else
              excphnd_a  when (EXCRQ_XM1 = '1' and BOOTEV_XXA = '0') else
              excphnd_a  when (INTRQ_XXA = '1' and BOOTEV_XXA = '0') else
              NEXTPC_RDA ;

	-- ### ------------------------------------------------------ ###
	-- #   prepare the data to be written into the status register:	#
	-- #								#
	-- #     - reset:						#
	-- #         initialize the status register (set the Bootstrap	#
	-- #         Exception Vector, reset the global Interrupt Mask	#
	-- #         and put the processor in kernel mode		#
	-- #     - exception and interrupt:				#
	-- #         the status register is saved.			#
	-- ### ------------------------------------------------------ ###

WSR_XXA     <= EXCRQ_XM0 or EXCRQ_XM1 or INTRQ_XXA or RESET_RXA;

NEXTSR_XXA  <= X"00400000"                     when (RESET_RXA = '1') else
               NEXTSR_RXA (31 downto 6) &
               NEXTSR_RXA ( 3 downto 0) & "00" ;

	-- ### ------------------------------------------------------ ###
	-- #   prepare the data to be written into the Exception	#
	-- # Program Counter register (EPC):				#
	-- #								#
	-- #     - interrupt:						#
	-- #         the address of the first unexecuted instruction is	#
	-- #         saved unless the first unexecuted instruction is	#
	-- #         in the delayed slot of a branch instruction in	#
	-- #         which case the address of the branch instruction	#
	-- #         is saved.						#
	-- ### ------------------------------------------------------ ###

EPC_XXA <= PC_RD0     when (PRECED_RDA = '1' and BDSLOT_RD0 = '0') else
           PC_RD1     when (PRECED_RDA = '0' and BDSLOT_RD1 = '0') else
           REDOPC_REA ;

	-- ### ------------------------------------------------------ ###
	-- #   prepare the data to be written into the Exception	#
	-- # Program Counter register (EPC):				#
	-- #								#
	-- #     - exception:						#
	-- #         the address of the faulty instruction is saved	#
	-- #         unless the faulty instruction is in the delayed	#
	-- #         slot of a branch instruction in which case the	#
	-- #         address of the branch instruction is saved.	#
	-- ### ------------------------------------------------------ ###

EPC_XM0  <= PC_RE0     when (                     BDSLOT_RE0 = '0') else
            PC_RE1     when (PRECED_REA = '0' and BDSLOT_RE0 = '1') else
            REDOPC_RMA ;

EPC_XM1  <= PC_RE1     when (                     BDSLOT_RE1 = '0') else
            PC_RE0     when (PRECED_REA = '1' and BDSLOT_RE1 = '1') else
            REDOPC_RMA ;

	-- ### ------------------------------------------------------ ###
	-- #   Exception Program Counter register is modified in case	#
	-- # of reset, interrupts or exceptions				#
	-- ### ------------------------------------------------------ ###

WEPC_XXA <= INTRQ_XXA or RESET_RXA;

WEPC_XM0 <= EXCRQ_XM0 and (    PRECED_REA or not EXCRQ_XM1);
WEPC_XM1 <= EXCRQ_XM1 and (not PRECED_REA or not EXCRQ_XM0);

	-- ### ------------------------------------------------------ ###
	-- #   exception request					#
	-- #     - check early exceptions (those who unvalidate the	#
	-- #       memory access during the Memory Access cycle)	#
	-- #     - check late exceptions (these one has no effect on	#
	-- #       the current memory access)				#
	-- ### ------------------------------------------------------ ###

LATEEX_XMA  <= DABUSER_XMA ;

EARLYEX_XM0 <= ILLGINS_RE0 or C0UNUSE_RE0                or
               IAMALGN_RE0 or IASVIOL_RE0 or IABUSER_RE0 or
               OVR_RE0     or BREAK_RE0   or SYSCALL_RE0 or
               LAMALGN_XM0 or LASVIOL_XM0                or
               SAMALGN_XM0 or SASVIOL_XM0                  ;

EARLYEX_XM1 <= ILLGINS_RE1 or C0UNUSE_RE1                or
               IAMALGN_RE1 or IASVIOL_RE1 or IABUSER_RE1 or
               OVR_RE1     or BREAK_RE1   or SYSCALL_RE1 or
               LAMALGN_XM1 or LASVIOL_XM1                or
               SAMALGN_XM1 or SASVIOL_XM1                  ;

EXCRQ_XM0   <= EARLYEX_XM0 or LATEEX_XMA;
EXCRQ_XM1   <= EARLYEX_XM1 or LATEEX_XMA;

	-- ### ------------------------------------------------------ ###
	-- #   interrupt request					#
	-- #     - check hadrware and software requests and interrupt	#
	-- #       mask							#
	-- ### ------------------------------------------------------ ###

SWINTRQ_XMA <= CAUSE_RXA ( 9 downto  8);
HWINTRQ_XXA <= CAUSE_RXA (15 downto 10);

GLBMSK_XXA  <= NEXTSR_RXA (0)          ;
ITMASK_XXA  <= NEXTSR_RXA (15 downto 8);

INTRQ_XXA   <= GLBMSK_XXA and ((ITMASK_XXA (7) and HWINTRQ_XXA (5)) or
                               (ITMASK_XXA (6) and HWINTRQ_XXA (4)) or
                               (ITMASK_XXA (5) and HWINTRQ_XXA (3)) or
                               (ITMASK_XXA (4) and HWINTRQ_XXA (2)) or
                               (ITMASK_XXA (3) and HWINTRQ_XXA (1)) or
                               (ITMASK_XXA (2) and HWINTRQ_XXA (0)) or
                               (ITMASK_XXA (1) and SWINTRQ_XMA (1)) or
                               (ITMASK_XXA (0) and SWINTRQ_XMA (0))   );

	-- ### ------------------------------------------------------ ###
	-- #   instruction flow control :				#
	-- #								#
	-- #   four cases can happen :					#
	-- #     (1) Kill : the instruction in the corresponding stage	#
	-- #                is killed					#
	-- #     (2) Stall: the instruction is not allowed to pass to	#
	-- #                the next pipe stage				#
	-- #     (3) Copy : the instruction is duplicated. A copy	#
	-- #                remains in the current stage and the other	#
	-- #                goes down the pipe				#
	-- #     (4) Exec : the instruction can be executed		#
	-- #								#
	-- #   Here follows a some of the situations that may occur:	#
	-- #   (here it is assumed that 0 preceds 1 in all stages)	#
	-- #								#
	-- #                          | I | D | E | M | W |		#
	-- #  ------------------------+---+---+---+---+---|		#
	-- #   reset                 0| K | K | K | K | K |		#
	-- #                         1| K | K | K | K | K |		#
	-- #                          |   |   |   |   |   |		#
	-- #   exception in 0        0| K | K | K | K | E |		#
	-- #                         1| K | K | K | K | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   exception in 1        0| K | K | K | E | E |		#
	-- #                         1| K | K | K | K | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   interrupt             0| K | K | K | E | E |		#
	-- #                         1| K | K | K | E | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   D_FRZ in 0            0| S | S | S | S | E |		#
	-- #                         1| S | S | S | S | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   D_FRZ in 1            0| S | S | S | E | E |		#
	-- #                         1| S | S | S | S | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   hazard in WBK         0| S | S | S | S | E |		#
	-- #                         1| S | S | S | S | S |		#
	-- #                          |   |   |   |   |   |		#
	-- #   hazard in MEM         0| S | S | S | E | E |		#
	-- #                         1| S | S | S | S | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   hazard in EXE 0       0| S | S | S | E | E |		#
	-- #                         1| S | S | S | E | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   hazard in EXE 1       0| S | S | E | E | E |		#
	-- #                         1| S | S | S | E | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   hazard in DEC 0       0| S | S | E | E | E |		#
	-- #                         1| S | S | E | E | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   hazard in DEC 1       0| S | E | E | E | E |		#
	-- #                         1| S | S | E | E | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   SLEEP in 0            0| S | C | E | E | E |		#
	-- #                         1| S | S | E | E | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   SLEEP in 1            0| S | E | E | E | E |		#
	-- #                         1| S | C | E | E | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   SWAP in 0 fst state   0| S | S | S | C | E |		#
	-- #                         1| S | S | S | S | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   SWAP in 1 fst state   0| S | S | S | E | E |		#
	-- #                         1| S | S | S | C | E |		#
	-- #                          |   |   |   |   |   |		#
	-- #   I_FRZ                 0| S | S | E | E | E |		#
	-- #                         1| S | S | E | E | E |		#
	-- #								#
	-- # Note that if more than one situation occur in the same	#
	-- # cycle the priority order is : Kill > Stall > Copy > Exec	#
	-- #								#
	-- ### ------------------------------------------------------ ###

	-- ### ------------------------------------------------------ ###
	-- #   first  level :						#
	-- #								#
	-- #   the instruction in Instruction Fetch is killed if :	#
	-- #     - a mispredicted branch condition has been detected in	#
	-- #       the first  pipeline					#
	-- #     - a previous instruction in MEM causes an exception	#
	-- #     - a hardware or software interrupt occurs		#
	-- #     - a hardware reset is detected				#
	-- #								#
	-- #   it is stalled if :					#
	-- #     - the next stage (Instruction Decode) is occupied	#
	-- #								#
	-- #   it is never copied					#
	-- ### ------------------------------------------------------ ###

KILL_SI0  <=     (   MISPRED_SD0 and EXEC_SD0                     ) or
                 (   MISPRED_SD1 and EXEC_SD1   and not PRECED_RIA) or
                     EXCRQ_XM1                                      or
                     EXCRQ_XM0                                      or
                     INTRQ_XXA                                      or
                     RESET_RXA                                             ;

STALL_SI0 <= not (   KILL_SI0                                         ) and
                  (  STALL_SD0   or  COPY_SD0                       or 
                   ((STALL_SI1   or  COPY_SI1 ) and not PRECED_RIA)   )    ;

COPY_SI0  <= '0';

EXEC_SI0  <= not (  KILL_SI0    or   STALL_SI0  or      COPY_SI0      )    ;

	-- ### ------------------------------------------------------ ###
	-- #   second level :						#
	-- #								#
	-- #   the instruction in Instruction Fetch is killed if :	#
	-- #     - a mispredicted branch condition has been detected in	#
	-- #       the pipeline						#
	-- #     - a previous instruction in MEM causes an exception	#
	-- #     - a hardware or software interrupt occurs		#
	-- #     - a hardware reset is detected				#
	-- #								#
	-- #   it is stalled if :					#
	-- #     - the next stage (Instruction Decode) is occupied	#
	-- #								#
	-- #   it is never copied					#
	-- ### ------------------------------------------------------ ###

KILL_SI1  <=     (   MISPRED_SD0 and EXEC_SD0   and     PRECED_RIA) or
                 (   MISPRED_SD1 and EXEC_SD1                     ) or
                     EXCRQ_XM1                                      or
                     EXCRQ_XM0                                      or
                     INTRQ_XXA                                      or
                     RESET_RXA                                             ;

STALL_SI1 <= not (   KILL_SI1                                         ) and
                  (  STALL_SD1   or  COPY_SD1                       or 
                   ((STALL_SI0   or  COPY_SI0 ) and     PRECED_RIA)   )    ;

COPY_SI1  <= '0';

EXEC_SI1  <= not (   KILL_SI1    or  STALL_SI1  or      COPY_SI1      )    ;

	-- ### ------------------------------------------------------ ###
	-- #   third  level :						#
	-- #								#
	-- #   the instruction in Instruction Fetch is killed if :	#
	-- #     - a mispredicted branch condition has been detected	#
	-- #     - a previous instruction in MEM causes an exception	#
	-- #     - a hardware or software interrupt occurs		#
	-- #     - a hardware reset is detected				#
	-- #								#
	-- #   it is stalled if :					#
	-- #     - the next stage (first  level in IFC) is occupied	#
	-- #								#
	-- #   it is never copied					#
	-- ### ------------------------------------------------------ ###

KILL_SI2  <=     (   MISPRED_SD0 and EXEC_SD0 )                     or
                 (   MISPRED_SD1 and EXEC_SD1 )                     or
                     EXCRQ_XM1                                      or
                     EXCRQ_XM0                                      or
                     INTRQ_XXA                                      or
                     RESET_RXA                                             ;

STALL_SI2 <= not (   KILL_SI2                                         ) and
                  (  STALL_SI0   or  COPY_SI0                         )    ;

COPY_SI2  <= '0';

EXEC_SI2  <= not (   KILL_SI2    or  STALL_SI2   or      COPY_SI2     )    ;

	-- ### ------------------------------------------------------ ###
	-- #   third  level :						#
	-- #								#
	-- #   the instruction in Instruction Fetch is killed if :	#
	-- #     - a mispredicted branch condition has been detected	#
	-- #     - a previous instruction in MEM causes an exception	#
	-- #     - a hardware or software interrupt occurs		#
	-- #     - a hardware reset is detected				#
	-- #								#
	-- #   it is stalled if :					#
	-- #     - the next stage (second level in IFC) is occupied	#
	-- #								#
	-- #   it is never copied					#
	-- ### ------------------------------------------------------ ###

KILL_SI3  <=     (   MISPRED_SD0 and EXEC_SD0 )                     or
                 (   MISPRED_SD1 and EXEC_SD1 )                     or
                     EXCRQ_XM1                                      or
                     EXCRQ_XM0                                      or
                     INTRQ_XXA                                      or
                     RESET_RXA                                             ;

STALL_SI3 <= not (   KILL_SI3                                         ) and
                  (  STALL_SI1   or  COPY_SI1                         )    ;

COPY_SI3  <= '0';

EXEC_SI3  <= not (   KILL_SI3    or  STALL_SI3   or      COPY_SI3     )    ;

	-- ### ------------------------------------------------------ ###
	-- #   first  level :						#
	-- #								#
	-- #   the instruction in Instruction Decode is killed if :	#
	-- #     - a previous instruction causes an exception in MEM	#
	-- #     - a hardware reset is detected				#
	-- #     - a hardware or a software interrupt occurs		#
	-- #								#
	-- #   it is stalled if :					#
	-- #     - the next stage (Execute) is occupied			#
	-- #     - a previous instruction in the same stage is stalled	#
	-- #       or copied						#
	-- #     - there is a data hazard that cannot be resolved by	#
	-- #       bypasses						#
	-- #     - the instruction is a branch and the delayed slot has	#
	-- #       not been fetched					#
	-- #								#
	-- #   it is copied if :					#
	-- #     - the current instruction is a Sleep			#
	-- ### ------------------------------------------------------ ###

KILL_SD0  <=         EXCRQ_XM1                                         or
                     EXCRQ_XM0                                         or
                     INTRQ_XXA                                         or
                     RESET_RXA                                                ;

STALL_SD0 <= not (   KILL_SD0                                            ) and
                  (  STALL_SE0   or      COPY_SE0                      or
                   ((STALL_SD1   or      COPY_SD1) and not PRECED_RIA) or
                     HAZARDS_SD0                                       or
                   ( I_BRNCH_SD0 and not VI_RI1    and     PRECED_RIA) or
                   ( I_BRNCH_SD0 and not VI_RI3    and not PRECED_RIA)   )    ;

COPY_SD0  <= not (   KILL_SD0    or      STALL_SD0                       ) and
                     CPYCRED_SD0                                              ;

EXEC_SD0  <= not (   KILL_SD0    or      STALL_SD0    or   COPY_SD0      )    ;

	-- ### ------------------------------------------------------ ###
	-- #   second level :						#
	-- #								#
	-- #   the instruction in Instruction Decode is killed if :	#
	-- #     - a previous instruction causes an exception in MEM	#
	-- #     - a hardware reset is detected				#
	-- #     - a hardware or a software interrupt occurs		#
	-- #								#
	-- #   it is stalled if :					#
	-- #     - the next stage (Execute) is occupied			#
	-- #     - a previous instruction in the same stage is stalled	#
	-- #       or copied						#
	-- #     - there is a data hazard that cannot be resolved by	#
	-- #       bypasses						#
	-- #     - the instruction is a branch and the delayed slot has	#
	-- #       not been fetched					#
	-- #								#
	-- #   it is copied if :					#
	-- #     - the current instruction is a Sleep			#
	-- ### ------------------------------------------------------ ###

KILL_SD1  <=         EXCRQ_XM1                                         or
                     EXCRQ_XM0                                         or
                     INTRQ_XXA                                         or
                     RESET_RXA                                                ;

STALL_SD1 <= not (   KILL_SD1                                            ) and
                  (  STALL_SE1   or      COPY_SE1                      or
                   ((STALL_SD0   or      COPY_SD0) and     PRECED_RIA) or
                     HAZARDS_SD1                                       or
                   ( I_BRNCH_SD1 and not VI_RI0    and not PRECED_RIA) or
                   ( I_BRNCH_SD1 and not VI_RI2    and     PRECED_RIA)   )    ;

COPY_SD1  <= not (   KILL_SD1    or      STALL_SD1                       ) and
                     CPYCRED_SD1                                              ;

EXEC_SD1  <= not (   KILL_SD1    or      STALL_SD1    or   COPY_SD1      )    ;

	-- ### ------------------------------------------------------ ###
	-- #   first  level :						#
	-- #								#
	-- #   the instruction in Execute is killed if :		#
	-- #     - a previous instruction cause an exception		#
	-- #     - a hardware reset is detected				#
	-- #     - a hardware or a software interrupt occurs		#
	-- #								#
	-- #   it is stalled if :					#
	-- #     - the next stage (Memory Access) is occupied		#
	-- #     - the previous instruction in the same stage is	#
	-- #       stalled or copied					#
	-- #     - there is a data hazard that cannot be resolved by	#
	-- #       bypasses						#
	-- #								#
	-- #   the instruction in Execute is never copied.		#
	-- ### ------------------------------------------------------ ###

KILL_SE0  <=       EXCRQ_XM1                                     or
                   EXCRQ_XM0                                     or
                   INTRQ_XXA                                     or
                   RESET_RXA                                            ;

STALL_SE0 <= not ( KILL_SE0                                        ) and
                 ( STALL_SM0   or COPY_SM0                       or
                 ((STALL_SE1   or COPY_SE1 ) and not PRECED_RDA) or
                   HAZARDS_SE0                                     )    ;

COPY_SE0  <= '0';

EXEC_SE0  <= not ( KILL_SE0    or STALL_SE0  or      COPY_SE0      )    ;

	-- ### ------------------------------------------------------ ###
	-- #   second level :						#
	-- #								#
	-- #   the instruction in Execute is killed if :		#
	-- #     - a previous instruction cause an exception		#
	-- #     - a hardware reset is detected				#
	-- #     - a hardware or a software interrupt occurs		#
	-- #								#
	-- #   it is stalled if :					#
	-- #     - the next stage (Memory Access) is occupied		#
	-- #     - the previous instruction in the same stage is	#
	-- #       stalled or copied					#
	-- #     - there is a data hazard that cannot be resolved by	#
	-- #       bypasses						#
	-- #								#
	-- #   the instruction in Execute is never copied.		#
	-- ### ------------------------------------------------------ ###

KILL_SE1  <=       EXCRQ_XM1                                     or
                   EXCRQ_XM0                                     or
                   INTRQ_XXA                                     or
                   RESET_RXA                                            ;

STALL_SE1 <= not ( KILL_SE1                                        ) and
                 ( STALL_SM1   or COPY_SM1                       or
                 ((STALL_SE0   or COPY_SE0 ) and     PRECED_RDA) or
                   HAZARDS_SE1                                     )    ;

COPY_SE1  <= '0';

EXEC_SE1  <= not ( KILL_SE1    or STALL_SE1  or      COPY_SE1      )    ;

	-- ### ------------------------------------------------------ ###
	-- #   first  level :						#
	-- #								#
	-- #   the instruction in Memory Access is killed if:		#
	-- #     - the previous instruction in the same stage causes	#
	-- #       an exception						#
	-- #     - it causes an exception				#
	-- #     - a hardware reset is detected				#
	-- #								#
	-- #   it is stalled if :					#
	-- #     - the next stage (Write Back) is occupied		#
	-- #     - the previous instruction in the same stage is	#
	-- #       stalled or copied					#
	-- #     - resource hazard (the previous instruction in the	#
	-- #       same stage is a memory access instruction and the	#
	-- #       instruction is a memory access instruction)		#
	-- #     - the data memory is not able to answer the request	#
	-- #								#
	-- #   it is copied if :					#
	-- #     - the current instruction has a copying credit		#
	-- #       (that is, it is a swap instruction and is making	#
	-- #       its first access).					#
	-- ### ------------------------------------------------------ ###

KILL_SM0  <=     ( EXCRQ_XM1                  and not PRECED_REA) or
                   EXCRQ_XM0                                      or
                   RESET_RXA                                             ;

STALL_SM0 <= not ( KILL_SM0                                         ) and
                 ( STALL_SW0   or COPY_SW0                        or
                 ((STALL_SM1   or COPY_SM1  ) and not PRECED_REA) or
                   HAZARDS_SM0                                    or
                 ( DACCESS_SM0                and     D_FRZ         ))    ;

COPY_SM0  <= not ( KILL_SM0    or STALL_SM0                         ) and
                   CPYCRED_SM0                                            ;

EXEC_SM0  <= not (KILL_SM0     or STALL_SM0   or      COPY_SM0      )     ;

	-- ### ------------------------------------------------------ ###
	-- #   second level :						#
	-- #								#
	-- #   the instruction in Memory Access is killed if:		#
	-- #     - the previous instruction in the same stage causes	#
	-- #       an exception						#
	-- #     - the instruction causes an exception			#
	-- #     - a hardware reset is detected				#
	-- #								#
	-- #   it is stalled if :					#
	-- #     - the next stage (Write Back) is occupied		#
	-- #     - the previous instruction in the same stage is	#
	-- #       stalled or copied					#
	-- #     - resource hazard (the previous instruction in the	#
	-- #       same stage is a memory access instruction and the	#
	-- #       instruction is a memory access instruction)		#
	-- #     - the data memory is not able to answer the request	#
	-- #								#
	-- #   it is copied if :					#
	-- #     - the current instruction has a copying credit		#
	-- #       (that is, it is a swap instruction and is making	#
	-- #       its first access).					#
	-- ### ------------------------------------------------------ ###

KILL_SM1  <=     ( EXCRQ_XM0                  and     PRECED_REA) or
                   EXCRQ_XM1                                      or
                   RESET_RXA                                             ;

STALL_SM1 <= not ( KILL_SM1                                         ) and
                 ( STALL_SW1   or COPY_SW1                        or
                 ((STALL_SM0   or COPY_SM0 )  and     PRECED_REA) or
                   HAZARDS_SM1                                    or
                 ( DACCESS_SM1                and     D_FRZ         ))   ;

COPY_SM1  <= not ( KILL_SM1    or STALL_SM1                         ) and
                   CPYCRED_SM1                                           ;

EXEC_SM1  <= not (KILL_SM1     or STALL_SM1   or      COPY_SM1      )    ;

	-- ### ------------------------------------------------------ ###
	-- #   first  level :						#
	-- #								#
	-- #   the instruction in Write Back is killed  if :		#
	-- #     - a hardware reset is detected				#
	-- #								#
	-- #   the instruction in Write Back is stalled if :		#
	-- #     - resource hazard (a previous instructions in the same	#
	-- #       stage writes in the same register)			#
	-- ### ------------------------------------------------------ ###

KILL_SW0  <= RESET_RXA;
STALL_SW0 <= not (KILL_SW0                         ) and HAZARDS_SW0;
COPY_SW0  <= '0' ;
EXEC_SW0  <= not (KILL_SW0 or STALL_SW0 or COPY_SW0);

	-- ### ------------------------------------------------------ ###
	-- #   second level :						#
	-- #								#
	-- #   the instruction in Write Back is killed  if :		#
	-- #     - a hardware reset is detected				#
	-- #								#
	-- #   the instruction in Write Back is stalled if :		#
	-- #     - resource hazard (a previous instructions in the same	#
	-- #       stage writes in the same register)			#
	-- ### ------------------------------------------------------ ###

KILL_SW1  <= RESET_RXA;
STALL_SW1 <= not (KILL_SW1                         ) and HAZARDS_SW1;
COPY_SW1  <= '0' ;
EXEC_SW1  <= not (KILL_SW1 or STALL_SW1 or COPY_SW1);

	-- ### ------------------------------------------------------ ###
	-- #   actions on registers :					#
	-- #								#
	-- #   Three actions may be made on control registers:		#
	-- #      (1) shift : shift a new instruction into the stage	#
	-- #      (2) bubble: introduce a bubble (nop) into the pipe	#
	-- #      (3) hold  : hold the instruction			#
	-- #								#
	-- #   In each stage the action can be defined by the following	#
	-- # table (note that the virtual stage after the Write Back is	#
	-- # always executing):						#
	-- #								#
	-- #   stage   next stage   action in stage			#
	-- #   ------+------------+----------------			#
	-- #     K   |     K      |    bubble				#
	-- #     K   |     S      |    hold				#
	-- #     K   |     C      |    hold				#
	-- #     K   |     E      |    bubble				#
	-- #    -----+------------+----------------			#
	-- #     S   |     S      |    hold				#
	-- #     S   |     C      |    hold				#
	-- #     S   |     E      |    bubble				#
	-- #    -----+------------+----------------			#
	-- #     C   |     E      |    shift				#
	-- #    -----+------------+----------------			#
	-- #     E   |     E      |    shift				#
	-- ### ------------------------------------------------------ ###

BUBBLE_SI0 <= (EXEC_SD0 and (KILL_SI0 or STALL_SI0)) or (KILL_SI0 and KILL_SD0);
HOLD_SI0   <=  STALL_SD0 or  COPY_SD0;
SHIFT_SI0  <=  EXEC_SI0  or  COPY_SI0;

BUBBLE_SI1 <= (EXEC_SD1 and (KILL_SI1 or STALL_SI1)) or (KILL_SI1 and KILL_SD1);
HOLD_SI1   <=  STALL_SD1 or  COPY_SD1;
SHIFT_SI1  <=  EXEC_SI1  or  COPY_SI1;

BUBBLE_SI2 <= (EXEC_SI0 and (KILL_SI2 or STALL_SI2)) or (KILL_SI2 and KILL_SI0);
HOLD_SI2   <=  STALL_SI0 or  COPY_SI0;
SHIFT_SI2  <=  EXEC_SI2  or  COPY_SI2;

BUBBLE_SI3 <= (EXEC_SI1 and (KILL_SI3 or STALL_SI3)) or (KILL_SI3 and KILL_SI1);
HOLD_SI3   <=  STALL_SI1 or  COPY_SI1;
SHIFT_SI3  <=  EXEC_SI3  or  COPY_SI3;

BUBBLE_SD0 <= (EXEC_SE0 and (KILL_SD0 or STALL_SD0)) or (KILL_SD0 and KILL_SE0);
HOLD_SD0   <=  STALL_SE0 or  COPY_SE0;
SHIFT_SD0  <=  EXEC_SD0  or  COPY_SD0;

BUBBLE_SD1 <= (EXEC_SE1 and (KILL_SD1 or STALL_SD1)) or (KILL_SD1 and KILL_SE1);
HOLD_SD1   <=  STALL_SE1 or  COPY_SE1;
SHIFT_SD1  <=  EXEC_SD1  or  COPY_SD1;

BUBBLE_SE0 <= (EXEC_SM0 and (KILL_SE0 or STALL_SE0)) or (KILL_SE0 and KILL_SM0);
HOLD_SE0   <=  STALL_SM0 or  COPY_SM0;
SHIFT_SE0  <=  EXEC_SE0  or  COPY_SE0;

BUBBLE_SE1 <= (EXEC_SM1 and (KILL_SE1 or STALL_SE1)) or (KILL_SE1 and KILL_SM1);
HOLD_SE1   <=  STALL_SM1 or  COPY_SM1;
SHIFT_SE1  <=  EXEC_SE1  or  COPY_SE1;

BUBBLE_SM0 <= (EXEC_SW0 and (KILL_SM0 or STALL_SM0)) or (KILL_SM0 and KILL_SW0);
HOLD_SM0   <=  STALL_SW0 or  COPY_SW0;
SHIFT_SM0  <=  EXEC_SM0  or  COPY_SM0;

BUBBLE_SM1 <= (EXEC_SW1 and (KILL_SM1 or STALL_SM1)) or (KILL_SM1 and KILL_SW1);
HOLD_SM1   <=  STALL_SW1 or  COPY_SW1;
SHIFT_SM1  <=  EXEC_SM1  or  COPY_SM1;

BUBBLE_SW0 <=                KILL_SW0 or STALL_SW0                             ;
HOLD_SW0   <=  '0';
SHIFT_SW0  <=  EXEC_SW0  or  COPY_SW0;

BUBBLE_SW1 <=                KILL_SW1 or STALL_SW1                             ;
HOLD_SW1   <=  '0';
SHIFT_SW1  <=  EXEC_SW1  or  COPY_SW1;

	-- ### ------------------------------------------------------ ###
	-- #   actions on registers :					#
	-- #								#
	-- #   Two actions may be made on data registers (note that	#
	-- # Write Back is always loading) :				#
	-- #								#
	-- #      (1) load : load a new data into  the reg. (C or E)	#
	-- #      (2) keep : hold the same data in the reg. (K or S)	#
	-- ### ------------------------------------------------------ ###

LOAD_SI0 <= COPY_SI0 or EXEC_SI0 ;
KEEP_SI0 <= KILL_SI0 or STALL_SI0;

LOAD_SI1 <= COPY_SI1 or EXEC_SI1 ;
KEEP_SI1 <= KILL_SI1 or STALL_SI1;

LOAD_SI2 <= COPY_SI2 or EXEC_SI2 ;
KEEP_SI2 <= KILL_SI2 or STALL_SI2;

LOAD_SI3 <= COPY_SI3 or EXEC_SI3 ;
KEEP_SI3 <= KILL_SI3 or STALL_SI3;

LOAD_SD0 <= COPY_SD0 or EXEC_SD0 ;
KEEP_SD0 <= KILL_SD0 or STALL_SD0;

LOAD_SD1 <= COPY_SD1 or EXEC_SD1 ;
KEEP_SD1 <= KILL_SD1 or STALL_SD1;

LOAD_SE0 <= COPY_SE0 or EXEC_SE0 ;
KEEP_SE0 <= KILL_SE0 or STALL_SE0;

LOAD_SE1 <= COPY_SE1 or EXEC_SE1 ;
KEEP_SE1 <= KILL_SE1 or STALL_SE1;

LOAD_SM0 <= COPY_SM0 or EXEC_SM0 ;
KEEP_SM0 <= KILL_SM0 or STALL_SM0;

LOAD_SM1 <= COPY_SM1 or EXEC_SM1 ;
KEEP_SM1 <= KILL_SM1 or STALL_SM1;

LOAD_SW0 <= COPY_SW0 or EXEC_SW0 ;
KEEP_SW0 <= KILL_SW0 or STALL_SW0;

LOAD_SW1 <= COPY_SW1 or EXEC_SW1 ;
KEEP_SW1 <= KILL_SW1 or STALL_SW1;

	-- ### ------------------------------------------------------ ###
	-- #   assign registers (those related to a pipeline cycle)	#
	-- # Instruction Fetch cycle					#
	-- ### ------------------------------------------------------ ###

IFC_CYCLE : block (CK_SXA = '1' and not CK_SXA'STABLE)
begin

  VI_RI0      <= guarded
                 '0'        when (BUBBLE_SI0 = '1'                 ) else
                 '1'        when (HOLD_SI0   = '1' and VI_RI0 = '1') else
                 '1'        when (SHIFT_SI0  = '1' and VI_RI2 = '1') else
                 VI_SI0     ;

  I_RI0       <= guarded
                 nop_i      when (BUBBLE_SI0 = '1'                 ) else
                 I_RI0      when (HOLD_SI0   = '1' and VI_RI0 = '1') else
                 I_RI2      when (SHIFT_SI0  = '1' and VI_RI2 = '1') else
                 I_SI0      ;

  PC_RI0      <= guarded
                 NEXTPC_XXA when (BUBBLE_SI0 = '1'                 ) else
                 PC_RI0     when (HOLD_SI0   = '1' and VI_RI0 = '1') else
                 PC_RI2     when (SHIFT_SI0  = '1' and VI_RI2 = '1') else
                 PC_SI0     ;

  BDSLOT_RI0  <= guarded
                 '0'        when (BUBBLE_SI0 = '1'                 ) else
                 BDSLOT_XD0 when (HOLD_SI0   = '1' and VI_RI0 = '1') else
                 BDSLOT_XI0 when (SHIFT_SI0  = '1' and VI_RI2 = '1') else
                 BDSLOT_XI0 ;

  VI_RI1      <= guarded
                 '0'        when (BUBBLE_SI1 = '1'                 ) else
                 '1'        when (HOLD_SI1   = '1' and VI_RI1 = '1') else
                 '1'        when (SHIFT_SI1  = '1' and VI_RI3 = '1') else
                 VI_SI1     ;

  I_RI1       <= guarded
                 nop_i      when (BUBBLE_SI1 = '1'                 ) else
                 I_RI1      when (HOLD_SI1   = '1' and VI_RI1 = '1') else
                 I_RI3      when (SHIFT_SI1  = '1' and VI_RI3 = '1') else
                 I_SI1      ;

  PC_RI1      <= guarded
                 NEXTPC_XXA when (BUBBLE_SI1 = '1'                 ) else
                 PC_RI1     when (HOLD_SI1   = '1' and VI_RI1 = '1') else
                 PC_RI3     when (SHIFT_SI1  = '1' and VI_RI3 = '1') else
                 PC_SI1     ;

  BDSLOT_RI1  <= guarded
                 '0'        when (BUBBLE_SI1 = '1'                 ) else
                 BDSLOT_XD1 when (HOLD_SI1   = '1' and VI_RI1 = '1') else
                 BDSLOT_XI1 when (SHIFT_SI1  = '1' and VI_RI3 = '1') else
                 BDSLOT_XI1 ;

  VI_RI2      <= guarded
                 '0'        when (BUBBLE_SI2 = '1'                 ) else
                 '1'        when (HOLD_SI2   = '1' and VI_RI2 = '1') else
                 '0'        when (HOLD_SI3   = '1' and VI_RI3 = '1') else
                 VI_SI0     when (BUBBLE_SI0 = '1'                 ) else
                 VI_SI0     when (HOLD_SI0   = '1' and VI_RI0 = '1') else
                 VI_SI0     when (SHIFT_SI0  = '1' and VI_RI2 = '1') else
                 '0'        ;

  I_RI2       <= guarded
                 nop_i      when (BUBBLE_SI2 = '1'                 ) else
                 I_RI2      when (HOLD_SI2   = '1' and VI_RI2 = '1') else
                 nop_i      when (HOLD_SI3   = '1' and VI_RI3 = '1') else
                 I_SI0      when (BUBBLE_SI0 = '1'                 ) else
                 I_SI0      when (HOLD_SI0   = '1' and VI_RI0 = '1') else
                 I_SI0      when (SHIFT_SI0  = '1' and VI_RI2 = '1') else
                 nop_i      ;

  PC_RI2      <= guarded
                 NEXTPC_XXA when (BUBBLE_SI2 = '1'                 ) else
                 PC_RI2     when (HOLD_SI2   = '1' and VI_RI2 = '1') else
--               PC_SI1     when (HOLD_SI3   = '1' and VI_RI3 = '1') else
                 NEXTPC_RDA when (HOLD_SI3   = '1' and VI_RI3 = '1') else
                 PC_SI0     when (BUBBLE_SI0 = '1'                 ) else
                 PC_SI0     when (HOLD_SI0   = '1' and VI_RI0 = '1') else
                 PC_SI0     when (SHIFT_SI0  = '1' and VI_RI2 = '1') else
                 FIPC_SI1   ;

  VI_RI3      <= guarded
                 '0'        when (BUBBLE_SI3 = '1'                 ) else
                 '1'        when (HOLD_SI3   = '1' and VI_RI3 = '1') else
                 '0'        when (HOLD_SI2   = '1' and VI_RI2 = '1') else
                 VI_SI1     when (BUBBLE_SI1 = '1'                 ) else
                 VI_SI1     when (HOLD_SI1   = '1' and VI_RI1 = '1') else
                 VI_SI1     when (SHIFT_SI1  = '1' and VI_RI3 = '1') else
                 '0'        ;

  I_RI3       <= guarded
                 nop_i      when (BUBBLE_SI3 = '1'                 ) else
                 I_RI3      when (HOLD_SI3   = '1' and VI_RI3 = '1') else
                 nop_i      when (HOLD_SI2   = '1' and VI_RI2 = '1') else
                 I_SI1      when (BUBBLE_SI1 = '1'                 ) else
                 I_SI1      when (HOLD_SI1   = '1' and VI_RI1 = '1') else
                 I_SI1      when (SHIFT_SI1  = '1' and VI_RI3 = '1') else
                 nop_i      ;

  PC_RI3      <= guarded
                 NEXTPC_XXA when (BUBBLE_SI3 = '1'                 ) else
                 PC_RI3     when (HOLD_SI3   = '1' and VI_RI3 = '1') else
--               PC_SI1     when (HOLD_SI2   = '1' and VI_RI2 = '1') else
                 NEXTPC_RDA when (HOLD_SI2   = '1' and VI_RI2 = '1') else
                 PC_SI1     when (BUBBLE_SI1 = '1'                 ) else
                 PC_SI1     when (HOLD_SI1   = '1' and VI_RI1 = '1') else
                 PC_SI1     when (SHIFT_SI1  = '1' and VI_RI3 = '1') else
                 FIPC_SI1   ;

  IREAD_RIA   <= guarded    IREAD_SIA;

  PRECED_RIA <= guarded
                 '1'            when ( RESET_RXA               = '1') else
                 not PRECED_RIA when ((HOLD_SI0  xor HOLD_SI1) = '1') else
                     PRECED_RIA when ((HOLD_SI0  and HOLD_SI1) = '1') else
                     PRECED_RIA ;

end block;

	-- ### ------------------------------------------------------ ###
	-- #   assign registers (those related to a pipeline cycle)	#
	-- # Instruction Decode cycle					#
	-- #								#
	-- #  nextpc :							#
	-- #     - in case of hardware events (reset, exception or	#
	-- #       interrupt) set the next address to a known value	#
	-- #       (reset or interrupt handler address). In other cases	#
	-- #       nextpc is considered as a data register.		#
	-- ### ------------------------------------------------------ ###

DEC_CYCLE : block (CK_SXA = '1' and not CK_SXA'STABLE)
begin

  I_RD0       <= guarded nop_i        when (BUBBLE_SD0 = '1') else
                         I_RD0        when (HOLD_SD0   = '1') else
                         I_RI0        ;
  I_RD1       <= guarded nop_i        when (BUBBLE_SD1 = '1') else
                         I_RD1        when (HOLD_SD1   = '1') else
                         I_RI1        ;

  I_TYPE_RD0  <= guarded nop_type     when (BUBBLE_SD0 = '1') else
                         I_TYPE_RD0   when (HOLD_SD0   = '1') else
                         I_TYPE_SD0   ;
  I_TYPE_RD1  <= guarded nop_type     when (BUBBLE_SD1 = '1') else
                         I_TYPE_RD1   when (HOLD_SD1   = '1') else
                         I_TYPE_SD1   ;

  OPCOD_RD0   <= guarded addu_i       when (BUBBLE_SD0 = '1') else
                         OPCOD_RD0    when (HOLD_SD0   = '1') else
                         OPCOD_SD0    ;
  OPCOD_RD1   <= guarded addu_i       when (BUBBLE_SD1 = '1') else
                         OPCOD_RD1    when (HOLD_SD1   = '1') else
                         OPCOD_SD1    ;

  RS_RD0      <= guarded "00000"      when (BUBBLE_SD0 = '1') else
                         RS_RD0       when (HOLD_SD0   = '1') else
                         RS_SD0       ;
  RS_RD1      <= guarded "00000"      when (BUBBLE_SD1 = '1') else
                         RS_RD1       when (HOLD_SD1   = '1') else
                         RS_SD1       ;

  RT_RD0      <= guarded "00000"      when (BUBBLE_SD0 = '1') else
                         RT_RD0       when (HOLD_SD0   = '1') else
                         RT_SD0       ;
  RT_RD1      <= guarded "00000"      when (BUBBLE_SD1 = '1') else
                         RT_RD1       when (HOLD_SD1   = '1') else
                         RT_SD1       ;

  RD_RD0      <= guarded "00000"      when (BUBBLE_SD0 = '1') else
                         RD_RD0       when (HOLD_SD0   = '1') else
                         RD_SD0       ;
  RD_RD1      <= guarded "00000"      when (BUBBLE_SD1 = '1') else
                         RD_RD1       when (HOLD_SD1   = '1') else
                         RD_SD1       ;

  COP0D_RD0   <= guarded "00000"      when (BUBBLE_SD0 = '1') else
                         COP0D_RD0    when (HOLD_SD0   = '1') else
                         COP0D_SD0    ;
  COP0D_RD1   <= guarded "00000"      when (BUBBLE_SD1 = '1') else
                         COP0D_RD1    when (HOLD_SD1   = '1') else
                         COP0D_SD1    ;

  ILLGINS_RD0 <= guarded '0'          when (BUBBLE_SD0 = '1') else
                         ILLGINS_RD0  when (HOLD_SD0   = '1') else
                         ILLGINS_XD0  ;
  ILLGINS_RD1 <= guarded '0'          when (BUBBLE_SD1 = '1') else
                         ILLGINS_RD1  when (HOLD_SD1   = '1') else
                         ILLGINS_XD1  ;

  BDSLOT_RD0  <= guarded BDSLOT_XD0   when (BUBBLE_SD0 = '1') else
                         BDSLOT_RD0   when (HOLD_SD0   = '1') else
                         BDSLOT_XD0   ;
  BDSLOT_RD1  <= guarded BDSLOT_XD1   when (BUBBLE_SD1 = '1') else
                         BDSLOT_RD1   when (HOLD_SD1   = '1') else
                         BDSLOT_XD1   ;

  C0UNUSE_RD0 <= guarded '0'          when (BUBBLE_SD0 = '1') else
                         C0UNUSE_RD0  when (HOLD_SD0   = '1') else
                         C0UNUSE_XD0  ;
  C0UNUSE_RD1 <= guarded '0'          when (BUBBLE_SD1 = '1') else
                         C0UNUSE_RD1  when (HOLD_SD1   = '1') else
                         C0UNUSE_XD1  ;

  NEXTPC_RDA  <= guarded NEXTPC_XXA   when (INTRQ_XXA   = '1' or
                                            EXCRQ_XM0   = '1' or
                                            EXCRQ_XM1   = '1' or
                                            RESET_RXA   = '1'    ) else
                         NEXTPC_SD0   when (I_BRNCH_SD0 = '1' and
                                            LOAD_SD0    = '1'    ) else
                         NEXTPC_SD1   when (I_BRNCH_SD1 = '1' and
                                            LOAD_SD1    = '1'    ) else
                         SEQADR_SDA   ;

  SOPER_RD0   <= guarded SOPER_SE0    when (KEEP_SD0   = '1') else
                         SOPER_SD0    ;
  SOPER_RD1   <= guarded SOPER_SE1    when (KEEP_SD1   = '1') else
                         SOPER_SD1    ;

  TOPER_RD0   <= guarded TOPER_SE0    when (KEEP_SD0   = '1') else
                         TOPER_SD0    ;
  TOPER_RD1   <= guarded TOPER_SE1    when (KEEP_SD1   = '1') else
                         TOPER_SD1    ;

  IOPER_RD0   <= guarded IOPER_RD0    when (KEEP_SD0   = '1') else
                         IOPER_SD0    ;
  IOPER_RD1   <= guarded IOPER_RD1    when (KEEP_SD1   = '1') else
                         IOPER_SD1    ;

  MODE_RD0    <= guarded MODE_RD0     when (KEEP_SD0   = '1') else
                         MODE_SD0     ;
  MODE_RD1    <= guarded MODE_RD1     when (KEEP_SD1   = '1') else
                         MODE_SD1     ;

  PC_RD0      <= guarded PC_RD0       when (HOLD_SD0   = '1') else
                         PC_RI0       ;
  PC_RD1      <= guarded PC_RD1       when (HOLD_SD1   = '1') else
                         PC_RI1       ;

  PRECED_RDA <= guarded
                 '1'            when ( RESET_RXA               = '1') else
                 not PRECED_RDA when ((HOLD_SD0  xor HOLD_SD1) = '1') else
                     PRECED_RDA when ((HOLD_SD0  and HOLD_SD1) = '1') else
                     PRECED_RIA ;

end block;

	-- ### ------------------------------------------------------ ###
	-- #   assign registers (those related to a pipeline cycle)	#
	-- # Execute cycle (first and second levels)			#
	-- ### ------------------------------------------------------ ###

EXE_CYCLE : block (CK_SXA = '1' and not CK_SXA'STABLE)
begin

		-- ### ---------------------------------------------- ###
		-- #   control registers				#
		-- ### ---------------------------------------------- ###

  I_RE0       <= guarded nop_i       when (BUBBLE_SE0 = '1') else
                         I_RE0       when (HOLD_SE0   = '1') else
                         I_RD0       ;
  I_RE1       <= guarded nop_i       when (BUBBLE_SE1 = '1') else
                         I_RE1       when (HOLD_SE1   = '1') else
                         I_RD1       ;

  I_TYPE_RE0  <= guarded nop_type    when (BUBBLE_SE0 = '1') else
                         I_TYPE_RE0  when (HOLD_SE0   = '1') else
                         I_TYPE_RD0  ;
  I_TYPE_RE1  <= guarded nop_type    when (BUBBLE_SE1 = '1') else
                         I_TYPE_RE1  when (HOLD_SE1   = '1') else
                         I_TYPE_RD1  ;

  OPCOD_RE0   <= guarded addu_i      when (BUBBLE_SE0 = '1') else
                         OPCOD_RE0   when (HOLD_SE0   = '1') else
                         OPCOD_RD0   ;
  OPCOD_RE1   <= guarded addu_i      when (BUBBLE_SE1 = '1') else
                         OPCOD_RE1   when (HOLD_SE1   = '1') else
                         OPCOD_RD1   ;

  BDSLOT_RE0  <= guarded BDSLOT_RD0  when (BUBBLE_SE0 = '1') else
                         BDSLOT_RE0  when (HOLD_SE0   = '1') else
                         BDSLOT_RD0  ;
  BDSLOT_RE1  <= guarded BDSLOT_RD1  when (BUBBLE_SE1 = '1') else
                         BDSLOT_RE1  when (HOLD_SE1   = '1') else
                         BDSLOT_RD1  ;

  RD_RE0      <= guarded "00000"     when (BUBBLE_SE0 = '1') else
                         RD_RE0      when (HOLD_SE0   = '1') else
                         RD_RD0      ;
  RD_RE1      <= guarded "00000"     when (BUBBLE_SE1 = '1') else
                         RD_RE1      when (HOLD_SE1   = '1') else
                         RD_RD1      ;

  COP0D_RE0   <= guarded "00000"     when (BUBBLE_SE0 = '1') else
                         COP0D_RE0   when (HOLD_SE0   = '1') else
                         COP0D_RD0   ;
  COP0D_RE1   <= guarded "00000"     when (BUBBLE_SE1 = '1') else
                         COP0D_RE1   when (HOLD_SE1   = '1') else
                         COP0D_RD1   ;

  OVR_RE0     <= guarded '0'         when (BUBBLE_SE0 = '1') else
                         OVR_RE0     when (HOLD_SE0   = '1') else
                         OVR_XE0     ;
  OVR_RE1     <= guarded '0'         when (BUBBLE_SE1 = '1') else
                         OVR_RE1     when (HOLD_SE1   = '1') else
                         OVR_XE1     ;

  IAMALGN_RE0 <= guarded '0'         when (BUBBLE_SE0 = '1') else
                         IAMALGN_RE0 when (HOLD_SE0   = '1') else
                         IAMALGN_XE0 ;
  IAMALGN_RE1 <= guarded '0'         when (BUBBLE_SE1 = '1') else
                         IAMALGN_RE1 when (HOLD_SE1   = '1') else
                         IAMALGN_XE1 ;

  IASVIOL_RE0 <= guarded '0'         when (BUBBLE_SE0 = '1') else
                         IASVIOL_RE0 when (HOLD_SE0   = '1') else
                         IASVIOL_XE0 ;
  IASVIOL_RE1 <= guarded '0'         when (BUBBLE_SE1 = '1') else
                         IASVIOL_RE1 when (HOLD_SE1   = '1') else
                         IASVIOL_XE1 ;

  IABUSER_RE0 <= guarded '0'         when (BUBBLE_SE0 = '1') else
                         IABUSER_RE0 when (HOLD_SE0   = '1') else
                         IABUSER_XE0 ;
  IABUSER_RE1 <= guarded '0'         when (BUBBLE_SE1 = '1') else
                         IABUSER_RE1 when (HOLD_SE1   = '1') else
                         IABUSER_XE1 ;

  BREAK_RE0   <= guarded '0'         when (BUBBLE_SE0 = '1') else
                         BREAK_RE0   when (HOLD_SE0   = '1') else
                         BREAK_XE0   ;
  BREAK_RE1   <= guarded '0'         when (BUBBLE_SE1 = '1') else
                         BREAK_RE1   when (HOLD_SE1   = '1') else
                         BREAK_XE1   ;

  SYSCALL_RE0 <= guarded '0'         when (BUBBLE_SE0 = '1') else
                         SYSCALL_RE0 when (HOLD_SE0   = '1') else
                         SYSCALL_XE0 ;
  SYSCALL_RE1 <= guarded '0'         when (BUBBLE_SE1 = '1') else
                         SYSCALL_RE1 when (HOLD_SE1   = '1') else
                         SYSCALL_XE1 ;

  ILLGINS_RE0 <= guarded '0'         when (BUBBLE_SE0 = '1') else
                         ILLGINS_RE0 when (HOLD_SE0   = '1') else
                         ILLGINS_RD0 ;
  ILLGINS_RE1 <= guarded '0'         when (BUBBLE_SE1 = '1') else
                         ILLGINS_RE1 when (HOLD_SE1   = '1') else
                         ILLGINS_RD1 ;

  C0UNUSE_RE0 <= guarded '0'         when (BUBBLE_SE0 = '1') else
                         C0UNUSE_RE0 when (HOLD_SE0   = '1') else
                         C0UNUSE_RD0 ;
  C0UNUSE_RE1 <= guarded '0'         when (BUBBLE_SE1 = '1') else
                         C0UNUSE_RE1 when (HOLD_SE1   = '1') else
                         C0UNUSE_RD1 ;

		-- ### ---------------------------------------------- ###
		-- #   data registers					#
		-- ### ---------------------------------------------- ###

  PC_RE0      <= guarded PC_RE0      when (HOLD_SE0   = '1') else
                         PC_RD0      ;
  PC_RE1      <= guarded PC_RE1      when (HOLD_SE1   = '1') else
                         PC_RD1      ;

  RES_RE0     <= guarded RES_RE0     when (KEEP_SE0   = '1') else
                         RES_SE0     ;
  RES_RE1     <= guarded RES_RE1     when (KEEP_SE1   = '1') else
                         RES_SE1     ;

  WDATA_RE0   <= guarded WDATA_RE0   when (KEEP_SE0   = '1') else
                         TOPER_SE0   ;
  WDATA_RE1   <= guarded WDATA_RE1   when (KEEP_SE1   = '1') else
                         TOPER_SE1   ;

  MODE_RE0    <= guarded MODE_RE0    when (KEEP_SE0   = '1') else
                         MODE_RD0    ;
  MODE_RE1    <= guarded MODE_RE1    when (KEEP_SE1   = '1') else
                         MODE_RD1    ;

  REDOPC_REA  <= guarded
                 PC_RD0      when (LOAD_SE0 = '1' and WREDOPC_SE0 = '1') else
                 PC_RD1      when (LOAD_SE1 = '1' and WREDOPC_SE1 = '1') else
                 REDOPC_REA  ;

  NEXTPC_REA  <= guarded
                 NEXTPC_REA  when (KEEP_SE0 = '1' and WBADIA_XE0  = '1') else
                 NEXTPC_REA  when (KEEP_SE1 = '1' and WBADIA_XE1  = '1') else
                 NEXTPC_RDA  ;

  PRECED_REA <= guarded
                '1'            when ( RESET_RXA               = '1') else
                not PRECED_REA when ((HOLD_SE0  xor HOLD_SE1) = '1') else
                    PRECED_REA when ((HOLD_SE0  and HOLD_SE1) = '1') else
                    PRECED_RDA ;

		-- ### ---------------------------------------------- ###
		-- #   instruction's state :				#
		-- #							#
		-- #   A finite state machine controls the execution of	#
		-- # the non-RISC instructions that requires several	#
		-- # cycles. At each cycle, such a instruction make a	#
		-- # copy of itself in the pipeline stage and defines	#
		-- # the next state. The state machine remains active	#
		-- # until it reaches the state 0.			#
		-- #							#
		-- #   - the execution of a Swap requires two cycles	#
		-- #     in MEM.					#
		-- ### ---------------------------------------------- ###

ISTAT_RE0 <= guarded
             '0'       when (BUBBLE_SE0 = '1'                           ) else
             '1'       when (ISTAT_RE0  = '0' and OPCOD_RD0 = swap_i and
                             SHIFT_SE0  = '1'                           ) else
             '0'       when (ISTAT_RE0  = '1' and OPCOD_RE0 = swap_i and
                             SHIFT_SM0  = '1'                           ) else
             ISTAT_RE0 ;

ISTAT_RE1 <= guarded
             '0'       when (BUBBLE_SE1 = '1'                           ) else
             '1'       when (ISTAT_RE1  = '0' and OPCOD_RD1 = swap_i and
                             SHIFT_SE1  = '1'                           ) else
             '0'       when (ISTAT_RE1  = '1' and OPCOD_RE1 = swap_i and
                             SHIFT_SM1  = '1'                           ) else
             ISTAT_RE1 ;

end block;

	-- ### ------------------------------------------------------ ###
	-- #   assign registers (those related to a pipeline cycle)	#
	-- # Memory Access cycle					#
	-- ### ------------------------------------------------------ ###

MEM_CYCLE : block (CK_SXA = '1' and not CK_SXA'STABLE)
begin

  I_RM0       <= guarded nop_i       when (BUBBLE_SM0 = '1') else
                         I_RM0       when (HOLD_SM0   = '1') else
                         I_RE0       ;
  I_RM1       <= guarded nop_i       when (BUBBLE_SM1 = '1') else
                         I_RM1       when (HOLD_SM1   = '1') else
                         I_RE1       ;

  DREAD_RM0   <= guarded '0'         when (BUBBLE_SM0 = '1') else
                         '0'         when (HOLD_SM0   = '1') else
                         DREAD_SM0   ;
  DREAD_RM1   <= guarded '0'         when (BUBBLE_SM1 = '1') else
                         '0'         when (HOLD_SM1   = '1') else
                         DREAD_SM1   ;

  I_TYPE_RM0  <= guarded nop_type    when (BUBBLE_SM0 = '1') else
                         I_TYPE_RM0  when (HOLD_SM0   = '1') else
                         I_TYPE_RE0  ;
  I_TYPE_RM1  <= guarded nop_type    when (BUBBLE_SM1 = '1') else
                         I_TYPE_RM1  when (HOLD_SM1   = '1') else
                         I_TYPE_RE1  ;

  RD_RM0      <= guarded "00000"     when (BUBBLE_SM0 = '1') else
                         RD_RM0      when (HOLD_SM0   = '1') else
                         RD_SM0      ;
  RD_RM1      <= guarded "00000"     when (BUBBLE_SM1 = '1') else
                         RD_RM1      when (HOLD_SM1   = '1') else
                         RD_SM1      ;

  OPCOD_RM0   <= guarded addu_i      when (BUBBLE_SM0 = '1') else
                         OPCOD_RM0   when (HOLD_SM0   = '1') else
                         OPCOD_RE0   ;
  OPCOD_RM1   <= guarded addu_i      when (BUBBLE_SM1 = '1') else
                         OPCOD_RM1   when (HOLD_SM1   = '1') else
                         OPCOD_RE1   ;

  DATA_RM0    <= guarded DATA_RM0    when (KEEP_SM0   = '1') else
                         DATA_SM0    ;
  DATA_RM1    <= guarded DATA_RM1    when (KEEP_SM1   = '1') else
                         DATA_SM1    ;

  REDOPC_RMA  <= guarded
                 PC_RE0      when (LOAD_SM0 = '1' and WREDOPC_SM0 = '1') else
                 PC_RE1      when (LOAD_SM1 = '1' and WREDOPC_SM1 = '1') else
                 REDOPC_RMA  ;

  PRECED_RMA <= guarded
                 '1'            when ( RESET_RXA               = '1') else
                 not PRECED_RMA when ((HOLD_SM0  xor HOLD_SM1) = '1') else
                     PRECED_RMA when ((HOLD_SM0  and HOLD_SM1) = '1') else
                     PRECED_REA ;

end block;

	-- ### ------------------------------------------------------ ###
	-- #   assign registers (those related to a pipeline cycle)	#
	-- # Write Back cycle						#
	-- #								#
	-- #     - low and high registers				#
	-- #     - integer registers					#
	-- ### ------------------------------------------------------ ###

WBK_CYCLE  : block (CK_SXA = '1' and not CK_SXA'STABLE)
begin

  LO_RWA  <= guarded DATA_RM0 when (WLO_SW0 = '1'     and KEEP_SW0 = '0') else
                     DATA_RM1 when (WLO_SW1 = '1'     and KEEP_SW1 = '0') else
                     LO_RWA   ;

  HI_RWA  <= guarded DATA_RM0 when (WHI_SW0 = '1'     and KEEP_SW0 = '0') else
                     DATA_RM1 when (WHI_SW1 = '1'     and KEEP_SW1 = '0') else
                     HI_RWA   ;

  R1_RWA  <= guarded DATA_RM0 when (RD_RM0  = "00001" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "00001" and KEEP_SW1 = '0') else
                     R1_RWA   ;
  R2_RWA  <= guarded DATA_RM0 when (RD_RM0  = "00010" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "00010" and KEEP_SW1 = '0') else
                     R2_RWA   ;
  R3_RWA  <= guarded DATA_RM0 when (RD_RM0  = "00011" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "00011" and KEEP_SW1 = '0') else
                     R3_RWA   ;
  R4_RWA  <= guarded DATA_RM0 when (RD_RM0  = "00100" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "00100" and KEEP_SW1 = '0') else
                     R4_RWA   ;
  R5_RWA  <= guarded DATA_RM0 when (RD_RM0  = "00101" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "00101" and KEEP_SW1 = '0') else
                     R5_RWA   ;
  R6_RWA  <= guarded DATA_RM0 when (RD_RM0  = "00110" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "00110" and KEEP_SW1 = '0') else
                     R6_RWA   ;
  R7_RWA  <= guarded DATA_RM0 when (RD_RM0  = "00111" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "00111" and KEEP_SW1 = '0') else
                     R7_RWA   ;
  R8_RWA  <= guarded DATA_RM0 when (RD_RM0  = "01000" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "01000" and KEEP_SW1 = '0') else
                     R8_RWA   ;
  R9_RWA  <= guarded DATA_RM0 when (RD_RM0  = "01001" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "01001" and KEEP_SW1 = '0') else
                     R9_RWA   ;
  R10_RWA <= guarded DATA_RM0 when (RD_RM0  = "01010" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "01010" and KEEP_SW1 = '0') else
                     R10_RWA  ;
  R11_RWA <= guarded DATA_RM0 when (RD_RM0  = "01011" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "01011" and KEEP_SW1 = '0') else
                     R11_RWA  ;
  R12_RWA <= guarded DATA_RM0 when (RD_RM0  = "01100" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "01100" and KEEP_SW1 = '0') else
                     R12_RWA  ;
  R13_RWA <= guarded DATA_RM0 when (RD_RM0  = "01101" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "01101" and KEEP_SW1 = '0') else
                     R13_RWA  ;
  R14_RWA <= guarded DATA_RM0 when (RD_RM0  = "01110" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "01110" and KEEP_SW1 = '0') else
                     R14_RWA  ;
  R15_RWA <= guarded DATA_RM0 when (RD_RM0  = "01111" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "01111" and KEEP_SW1 = '0') else
                     R15_RWA  ;
  R16_RWA <= guarded DATA_RM0 when (RD_RM0  = "10000" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "10000" and KEEP_SW1 = '0') else
                     R16_RWA  ;
  R17_RWA <= guarded DATA_RM0 when (RD_RM0  = "10001" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "10001" and KEEP_SW1 = '0') else
                     R17_RWA  ;
  R18_RWA <= guarded DATA_RM0 when (RD_RM0  = "10010" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "10010" and KEEP_SW1 = '0') else
                     R18_RWA  ;
  R19_RWA <= guarded DATA_RM0 when (RD_RM0  = "10011" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "10011" and KEEP_SW1 = '0') else
                     R19_RWA  ;
  R20_RWA <= guarded DATA_RM0 when (RD_RM0  = "10100" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "10100" and KEEP_SW1 = '0') else
                     R20_RWA  ;
  R21_RWA <= guarded DATA_RM0 when (RD_RM0  = "10101" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "10101" and KEEP_SW1 = '0') else
                     R21_RWA  ;
  R22_RWA <= guarded DATA_RM0 when (RD_RM0  = "10110" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "10110" and KEEP_SW1 = '0') else
                     R22_RWA  ;
  R23_RWA <= guarded DATA_RM0 when (RD_RM0  = "10111" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "10111" and KEEP_SW1 = '0') else
                     R23_RWA  ;
  R24_RWA <= guarded DATA_RM0 when (RD_RM0  = "11000" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "11000" and KEEP_SW1 = '0') else
                     R24_RWA  ;
  R25_RWA <= guarded DATA_RM0 when (RD_RM0  = "11001" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "11001" and KEEP_SW1 = '0') else
                     R25_RWA  ;
  R26_RWA <= guarded DATA_RM0 when (RD_RM0  = "11010" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "11010" and KEEP_SW1 = '0') else
                     R26_RWA  ;
  R27_RWA <= guarded DATA_RM0 when (RD_RM0  = "11011" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "11011" and KEEP_SW1 = '0') else
                     R27_RWA  ;
  R28_RWA <= guarded DATA_RM0 when (RD_RM0  = "11100" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "11100" and KEEP_SW1 = '0') else
                     R28_RWA  ;
  R29_RWA <= guarded DATA_RM0 when (RD_RM0  = "11101" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "11101" and KEEP_SW1 = '0') else
                     R29_RWA  ;
  R30_RWA <= guarded DATA_RM0 when (RD_RM0  = "11110" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "11110" and KEEP_SW1 = '0') else
                     R30_RWA  ;
  R31_RWA <= guarded DATA_RM0 when (RD_RM0  = "11111" and KEEP_SW0 = '0') else
                     DATA_RM1 when (RD_RM1  = "11111" and KEEP_SW1 = '0') else
                     R31_RWA  ;
end block;

	-- ### ------------------------------------------------------ ###
	-- #   assign the the coprocessor zero's registers :		#
	-- #     Bad Virtual Address register				#
	-- ### ------------------------------------------------------ ###

BADVADR : block (CK_SXA = '1' and not CK_SXA'STABLE)
begin
  BADVADR_RXA <= guarded RES_RE0     when (WBADDA_XM0 = '1') else
                         RES_RE1     when (WBADDA_XM1 = '1') else
                         NEXTPC_REA  when (WBADIA_XMA = '1') else
                         BADVADR_RXA ;
end block;

	-- ### ------------------------------------------------------ ###
	-- #   assign the the coprocessor zero's registers :		#
	-- #     Cause register						#
	-- ### ------------------------------------------------------ ###

CAUSE : block (CK_SXA = '1' and not CK_SXA'STABLE)
begin
  CAUSE_RXA <= guarded
               CAUSE_XM0 when (WCAUSE_XM0 = '1'                   ) else
               CAUSE_XM1 when (WCAUSE_XM1 = '1'                   ) else
               CAUSE_XXA when (INTRQ_XXA  = '1'                   ) else
               CAUSE_SM0 when (WCAUSE_SM0 = '1' and KEEP_SM0 = '0') else
               CAUSE_SM1 when (WCAUSE_SM1 = '1' and KEEP_SM1 = '0') else
               CAUSE_SXA ;
end block;

	-- ### ------------------------------------------------------ ###
	-- #   assign the the coprocessor zero's registers :		#
	-- #     Exception Program Counter register			#
	-- ### ------------------------------------------------------ ###

EPC : block (CK_SXA = '1' and not CK_SXA'STABLE)
begin

  EPC_RXA <= guarded EPC_XM0 when (WEPC_XM0 = '1') else
                     EPC_XM1 when (WEPC_XM1 = '1') else
                     EPC_XXA when (WEPC_XXA = '1') else
                     EPC_RXA ;

end block;

	-- ### ------------------------------------------------------ ###
	-- #   assign the the coprocessor zero's registers :		#
	-- #     Status register					#
	-- ### ------------------------------------------------------ ###

NEXTSR : block (CK_SXA = '1' and not CK_SXA'STABLE)
begin

  NEXTSR_RXA <= guarded NEXTSR_XXA when (WSR_XXA = '1'                   ) else
                        NEXTSR_SM0 when (WSR_SM0 = '1' and KEEP_SM0 = '0') else
                        NEXTSR_SM1 when (WSR_SM1 = '1' and KEEP_SM1 = '0') else
                        NEXTSR_RXA ;
end block;

	-- ### ------------------------------------------------------ ###
	-- #   assign the the coprocessor zero's registers :		#
	-- #     Processor Revision Identifier register			#
	-- ### ------------------------------------------------------ ###

PRID : block (CK_SXA = '1' and not CK_SXA'STABLE)
begin
  PRID_RXA  <= guarded PRID_RXA;
end block;

	-- ### ------------------------------------------------------ ###
	-- #   assign registers (those directly controled by hardware)	#
	-- ### ------------------------------------------------------ ###

MISC : block (CK_SXA = '1' and not CK_SXA'STABLE)
begin
  RESET_RXA <= guarded not RESET_N;
end block;

	-- ### ------------------------------------------------------ ###
	-- #   assign outputs (instruction memory access):		#
	-- #								#
	-- #     - instruction address					#
	-- #     - instruction fetch request				#
	-- #     - instruction fetch acknowledge			#
	-- #								#
	-- # Notes:							#
	-- #     - disable the instruction fetch when the instruction	#
	-- #       in Execute stage is a Sleep. This is to avoid the	#
	-- #       discharge of the memory lines in the instruction	#
	-- #       cache. Since I_FTCH is a critical signal, it does	#
	-- #       not depend on the instruction present in Instruction	#
	-- #       Decode stage. The decode phase is used to detect the	#
	-- #       Sleep instruction and the memory access will be	#
	-- #       disabled in the next cycle.				#
	-- #     - the acknowledge signals to the cache that the new	#
	-- #       instruction fetched from the memory and saved inside	#
	-- #       the processor					#
	-- ### ------------------------------------------------------ ###

I_A    <= NEXTPC_RDA;

I_FTCH <= '0' when (OPCOD_RD0 = sleep_i or OPCOD_RD1 = sleep_i) else
          '1' ;

I_ACK <= IREAD_RIA;

	-- ### ------------------------------------------------------ ###
	-- #   assign outputs (data memory access):			#
	-- #								#
	-- #     - data address						#
	-- #     - output data						#
	-- #     - data access type					#
	-- #     - data access request					#
	-- #     - locked data access					#
	-- #     - data read acknowledge				#
	-- #								#
	-- # Notes:							#
	-- #     - disable the data access request in case of early	#
	-- #       execption or when a reset has occured.		#
	-- #     - a locked data access signals to the cache to not	#
	-- #       release the bus once the access has been acheived	#
	-- #     - the acknowledge signals to the cache that a data	#
	-- #       has been read from the memory and saved inside the	#
	-- #       processor						#
	-- ### ------------------------------------------------------ ###

D_A     <=     RES_RE0     when (DACCESS_SM0 = '1' and PRECED_REA  = '1') else
               RES_RE0     when (DACCESS_SM0 = '1' and DACCESS_SM1 = '0') else
               RES_RE1     ;

D_OUT   <=     WDATA_RE0   when (DACCESS_SM0 = '1' and PRECED_REA  = '1') else
               WDATA_RE0   when (DACCESS_SM0 = '1' and DACCESS_SM1 = '0') else
               WDATA_RE1   ;

D_ATYPE <=     DATYPE_SM0  when (DACCESS_SM0 = '1' and PRECED_REA  = '1') else
               DATYPE_SM0  when (DACCESS_SM0 = '1' and DACCESS_SM1 = '0') else
               DATYPE_SM1  ;

D_RQ    <= '0'             when (RESET_RXA   = '1'                      ) else
           not EARLYEX_XM0 when (DACCESS_SM0 = '1' and PRECED_REA  = '1') else
           not EARLYEX_XM0 when (DACCESS_SM0 = '1' and DACCESS_SM1 = '0') else
           not EARLYEX_XM1 when (DACCESS_SM1 = '1' and PRECED_REA  = '0') else
           not EARLYEX_XM1 when (DACCESS_SM1 = '1' and DACCESS_SM0 = '0') else
           '0'             ;

D_LOCK  <=     DLOCK_SM0   when (DACCESS_SM0 = '1' and PRECED_REA  = '1') else
               DLOCK_SM0   when (DACCESS_SM0 = '1' and DACCESS_SM1 = '0') else
               DLOCK_SM1   ;

D_ACK   <=     DREAD_RM0   or
               DREAD_RM1   ;

	-- ### ------------------------------------------------------ ###
	-- #   assign outputs (miscellaneous):				#
	-- ### ------------------------------------------------------ ###

SCOUT   <= '0';

end;
