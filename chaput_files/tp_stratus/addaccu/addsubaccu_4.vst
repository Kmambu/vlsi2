
-- =======================================================================
-- Coriolis Structural VHDL Driver
-- Generated on Dec 12, 2018, 18:38
-- 
-- To be interoperable with Alliance, it uses it's special VHDL subset.
-- ("man vhdl" under Alliance for more informations)
-- =======================================================================

entity addsubaccu_4 is
  port ( ck   : in bit
       ; sel  : in bit
       ; sub  : in bit
       ; a    : in bit_vector(3 downto 0)
       ; b    : in bit_vector(3 downto 0)
       ; cout : out bit
       ; s    : out bit_vector(3 downto 0)
       ; vdd  : in bit
       ; vss  : in bit
       );
end addsubaccu_4;

architecture structural of addsubaccu_4 is

  component inv_4
    port ( i0  : in bit_vector(3 downto 0)
         ; nq  : out bit_vector(3 downto 0)
         ; vdd : in bit
         ; vss : in bit
         );
  end component;

  component mux2_4
    port ( cmd : in bit
         ; i0  : in bit_vector(3 downto 0)
         ; i1  : in bit_vector(3 downto 0)
         ; q   : out bit_vector(3 downto 0)
         ; vdd : in bit
         ; vss : in bit
         );
  end component;

  component adder_4
    port ( cin  : in bit
         ; i0   : in bit_vector(3 downto 0)
         ; i1   : in bit_vector(3 downto 0)
         ; cout : out bit
         ; q    : out bit_vector(3 downto 0)
         ; vdd  : in bit
         ; vss  : in bit
         );
  end component;

  component reg_4
    port ( ck  : in bit
         ; d   : in bit_vector(3 downto 0)
         ; q   : out bit_vector(3 downto 0)
         ; vdd : in bit
         ; vss : in bit
         );
  end component;

  component mux_4
    port ( cmd : in bit
         ; i0  : in bit_vector(3 downto 0)
         ; i1  : in bit_vector(3 downto 0)
         ; s   : out bit_vector(3 downto 0)
         ; vdd : in bit
         ; vss : in bit
         );
  end component;

  component buf_x2
    port ( i   : in bit
         ; q   : out bit
         ; vdd : in bit
         ; vss : in bit
         );
  end component;

  signal adder_reg :  bit_vector(3 downto 0);
  signal mux_adder :  bit_vector(3 downto 0);
  signal mux_b     :  bit_vector(3 downto 0);
  signal not_b     :  bit_vector(3 downto 0);
  signal reg_out   :  bit_vector(3 downto 0);


begin

  buf_x2_i8 : buf_x2
  port map ( i   => reg_out(3)
           , q   => s(3)
           , vdd => vdd
           , vss => vss
           );

  buf_x2_i7 : buf_x2
  port map ( i   => reg_out(2)
           , q   => s(2)
           , vdd => vdd
           , vss => vss
           );

  buf_x2_i6 : buf_x2
  port map ( i   => reg_out(1)
           , q   => s(1)
           , vdd => vdd
           , vss => vss
           );

  buf_x2_i5 : buf_x2
  port map ( i   => reg_out(0)
           , q   => s(0)
           , vdd => vdd
           , vss => vss
           );

  mux_4_i4 : mux_4
  port map ( cmd => sel
           , i0  => reg_out(3 downto 0)
           , i1  => a(3 downto 0)
           , s   => mux_adder(3 downto 0)
           , vdd => vdd
           , vss => vss
           );

  reg_4_i3 : reg_4
  port map ( ck  => ck
           , d   => adder_reg(3 downto 0)
           , q   => reg_out(3 downto 0)
           , vdd => vdd
           , vss => vss
           );

  adder_4_i2 : adder_4
  port map ( cin  => sub
           , i0   => mux_adder(3 downto 0)
           , i1   => mux_b(3 downto 0)
           , cout => cout
           , q    => adder_reg(3 downto 0)
           , vdd  => vdd
           , vss  => vss
           );

  mux2_4_i1 : mux2_4
  port map ( cmd => sub
           , i0  => b(3 downto 0)
           , i1  => not_b(3 downto 0)
           , q   => mux_b(3 downto 0)
           , vdd => vdd
           , vss => vss
           );

  inv_4_i0 : inv_4
  port map ( i0  => b(3 downto 0)
           , nq  => not_b(3 downto 0)
           , vdd => vdd
           , vss => vss
           );

end structural;

